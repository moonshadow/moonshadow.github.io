<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wang Haowei - ℙƴ☂ℌøἤ Programmer</title>
  <subtitle>Python! Pythoner! Pythonest!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imiliya.com/"/>
  <updated>2016-09-03T06:57:17.000Z</updated>
  <id>http://imiliya.com/</id>
  
  <author>
    <name>Moonshadow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Beauty of Morden JavaScript</title>
    <link href="http://imiliya.com/2016/09/03/Beauty-of-Morden-JavaScript/"/>
    <id>http://imiliya.com/2016/09/03/Beauty-of-Morden-JavaScript/</id>
    <published>2016-09-02T21:15:31.000Z</published>
    <updated>2016-09-03T06:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么？你不是Python程序员么，怎么跑过来吹JavaScript了？窃以为只有幼稚的程序员才会偏执于一两门语言，故步自封，优秀的程序员就会知道博览众长，纳为己用。 JavaScript， 这门神奇的语言，从20年前一个礼拜就设计完成的玩具语言，经过岁月的洗礼，如今已经登上大雅之堂，从浏览器到服务器，甚至到嵌入式系统，JavaScript无处不在，如果一个程序员现在还对JavaScript不屑一顾或者不去学习一下(也许放到两三年前这并不是什么问题)，感觉可以回去反省一下。<br><a id="more"></a></p>
<p>本文的主题是Beauty of Morden JavaScript, 这个Morden Javascript包括ES6甚至ES7, 即便是没有正式敲定纳入standard，那些已经被各种开源项目大量使用的特性当然包含在其中。因为最近搞前端项目比较多，才能慢慢发现之前没有注意过的一些美的地方, 有时候也竟也会产生如果Python也能这样写有多好的想法。不多废话，下面开始我们的欣赏之旅。</p>
<h2 id="Modular-JavaScript"><a href="#Modular-JavaScript" class="headerlink" title="Modular JavaScript"></a>Modular JavaScript</h2><p>没有模块机制的JS简直就是个笑话，居然要通过closure来创造namespace，真是反人类。不过现在一切都结束了，ES6引入了<code>import</code>，终于不用care蛋疼的globals了。</p>
<p>math.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = (a, b) =&gt; a + b;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> name = <span class="string">'Math'</span>;</div><div class="line"><span class="keyword">const</span> negative = (a) =&gt; -a;</div></pre></td></tr></table></figure></p>
<p><code>math.js</code>输出了<code>add</code>和<code>name</code>函数，<code>negative</code>作为模块的私有函数，不能被其他模块访问.<br>default export 让开发者选一个自己觉得一个最重要的api输出，<br>而其他想要输出的api，只需要在前面加一个export就OK。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="string">'math'</span>; <span class="comment">// or import &#123; add &#125; from 'math';</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">'math'</span>; <span class="comment">// name 可以随便改名</span></div></pre></td></tr></table></figure>
<p>一个模块的对外的价值就在于他提供的API， 在Python里面，只要是模块中的变量(某些特殊情况除外)，都可以被其他模块直接import，<br>很容易造成一个模块写了一大坨函数，然后稀里糊涂的就全部<code>export</code>出去了，完全搞不清楚这个模块到底在干嘛。通过显示的声明export的变量，<br>程序员设计的时候就会更加不自主的思考这个模块的边界(boundary), 更能有意识的设计职责更加明确的模块。</p>
<p>有了<code>import</code>机制, IIFE, angular的依赖注入这些老把戏，都可以退出历史舞台了，sayonara！</p>
<h2 id="Simple-Javascript"><a href="#Simple-Javascript" class="headerlink" title="Simple Javascript"></a>Simple Javascript</h2><p>destructing<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123; a: <span class="number">12</span>, b: <span class="number">13</span>, c: <span class="number">14</span> &#125;;</div><div class="line"><span class="keyword">const</span> &#123; a, b, c &#125;  = obj;</div></pre></td></tr></table></figure></p>
<p>可以直接将一个对象解构</p>
<p>我想在Python里面做同样的事情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = &#123; &apos;a&apos;: 12, &apos;b&apos;: 13, &apos;c&apos;: 14 &#125;;</div><div class="line">a, b, c = obj;</div></pre></td></tr></table></figure></p>
<p>结果却是 a = ‘a’, b = ‘b’, c = ‘c’。</p>
<p>因为JS用的是pattern match，而python则是用的迭代器unpack，所以<code>a, b, c = iter(obj)</code>, ehmm，At this point, JS is better ！</p>
<p>object spread</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123; a: <span class="number">12</span>, b: <span class="number">13</span>, c: <span class="number">14</span> &#125;;</div><div class="line"><span class="keyword">const</span> newObj = &#123; ...obj, a: <span class="number">16</span>, d: <span class="number">18</span> &#125;;</div></pre></td></tr></table></figure>
<p>对象展开的语法真是给人屌炸天的感觉。直接基于已有对象的属性生成新的对象。How could I achieve this in Python?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">obj = &#123; &apos;a&apos;: 12, &apos;b&apos;: 13, &apos;c&apos;: 14 &#125;;</div><div class="line">new_obj = &#123; k: v for k, v in obj.items() &#125;</div><div class="line">new_obj[&apos;a&apos;] = 16</div><div class="line">new_obj[&apos;d&apos;] = 18</div></pre></td></tr></table></figure>
<p>不得不说JS又省了一筹.</p>
<h2 id="Functional-JavaScript"><a href="#Functional-JavaScript" class="headerlink" title="Functional JavaScript"></a>Functional JavaScript</h2><p>我们来看一个redux库中的<code>compose</code>函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> arg =&gt; arg</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</div><div class="line">  <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">  <span class="keyword">return</span> (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你能一眼看出来这个函数是干嘛的么？<br>compose函数接收的参数是一个包含多个函数的数组funcs，并返回一个新的函数，返回函数的函数被称为高阶函数.<br>这个返回的函数接收任何可能的参数，首先让funcs数组的最后一个函数作用于这些参数生成一个base value(<code>last(...args)</code>),<br>然后从右往左，funcs中的每一个函数一次作用于上一次调用的结果，即<code>f1(f2(f3(f4(base))))</code>, 这就是<code>reduceRight</code>做的事情，如果你学过Haskell或者Scala，<br>这玩意儿可谓是见怪不怪。 如今functional programming已经在JS中起到了不可替代的作用，你不妨看看(RxJS)[<a href="https://github.com/ReactiveX/rxjs]是玩的有多么妖娆" target="_blank" rel="external">https://github.com/ReactiveX/rxjs]是玩的有多么妖娆</a>.</p>
<p>通过这个例子我们看到,JavaScript玩起高阶函数一点也不含糊, 同时闭包仍有价值，不过是在函数式编程中大显身手而不是作为一个模块化的方案而显得不伦不类.</p>
<h2 id="Pythonic-Javascript"><a href="#Pythonic-Javascript" class="headerlink" title="Pythonic Javascript"></a>Pythonic Javascript</h2><p>从某一天开始, 所有人都在说JavaScript也来越像Python了, 不是么？</p>
<p>对比一下js和python版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * y.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</div><div class="line">  <span class="built_in">console</span>.log(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(index &lt; <span class="number">3</span>)</div><div class="line">    <span class="keyword">yield</span> index++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">a, *, b =  [1, 2, 3]</div><div class="line"></div><div class="line">def f(x, *y):</div><div class="line">  return x * len(y)</div><div class="line"></div><div class="line">for n in [1,2,3]:</div><div class="line">  print(n)</div><div class="line"></div><div class="line">def idMaker():</div><div class="line">  index = 0:</div><div class="line">  while x &lt; 3:</div><div class="line">    yield index ++</div></pre></td></tr></table></figure>
<p>魂淡，明明是我先的。。不过作为一个Python程序员, 看到JS这么赤裸裸的抄袭，真的是叫一个开心啊!来抄吧，抄个痛快！</p>
<h2 id="Evoling-JavaScript"><a href="#Evoling-JavaScript" class="headerlink" title="Evoling JavaScript"></a>Evoling JavaScript</h2><p>最神奇的是这门语言的进化速度，不知道下次又有什么新的提案，感觉在模仿Python的不归路上已经越走越远……</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>JavaScript，鉴于其继承自C语言系的语法体系，可能永远不可能到达Python的优雅简洁，但是其发展的速度，却早已把Python甩开了几条街.  作为一名Python程序员，是时候学习一下JavaScript了，推荐一下<a href="https://medium.com" target="_blank" rel="external">medium.com</a>, 每天读个一两篇文章，保证你不会后悔。顺便安利一发<a href="https://twitter.com/dan_abramov" target="_blank" rel="external">Dan Abramov</a>, redux和react hot loader的作者，z真心使人钦佩。这位老师向我们展示了一名优(颜)秀(值)专(爆)业(表)的程序员应该是什么样子——扎实的coding基本功，乐于分享的精神，天马行空的创造力,对问题洞若观火的判断力, 清晰的表达能力, 一丝不苟的作风, 对细节的专注…😂 再吹就要上天了。。不过讲道理吹一下也不过分. 如果你有兴趣，不妨去<a href="https://egghead.io/courses/getting-started-with-redux" target="_blank" rel="external">egghead.io</a>学习一下redux，至于能有多少收货，我只能说靠缘分，不过即便你对JavaScript或者ES6没有什么大的概念，听听老师的讲课感受一点仙气也是不错的！</p>
<p>个人观点:如果说代码水平决定了程序员的价值，那么人格魅力和精神诉求则是程序员真正的瑰宝。. Ask yourself, why are you coding? For money, for fun, for respect, or something else? 来，先干了这碗鸡汤!</p>
<p>一不小心就水了一篇，下一篇带来干货，”你所不知道的unicode”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么？你不是Python程序员么，怎么跑过来吹JavaScript了？窃以为只有幼稚的程序员才会偏执于一两门语言，故步自封，优秀的程序员就会知道博览众长，纳为己用。 JavaScript， 这门神奇的语言，从20年前一个礼拜就设计完成的玩具语言，经过岁月的洗礼，如今已经登上大雅之堂，从浏览器到服务器，甚至到嵌入式系统，JavaScript无处不在，如果一个程序员现在还对JavaScript不屑一顾或者不去学习一下(也许放到两三年前这并不是什么问题)，感觉可以回去反省一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实现一个简单优雅的Flask表单验证模块</title>
    <link href="http://imiliya.com/2016/08/23/flask-form/"/>
    <id>http://imiliya.com/2016/08/23/flask-form/</id>
    <published>2016-08-22T16:40:43.000Z</published>
    <updated>2016-09-02T19:57:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用Flask框架开发web应用的过程中，我们通常会在视图层写很多繁琐的代码来校验表单的数据，同时把提交的数据转换成业务需要的格式, 结果就是视图层的代码到处夹杂着表单验证的逻辑，显得错综复杂，难以维护。注意我所指的表单是更加广义的概念，包括query string或者通过设置Content-Type为<code>application/json</code>传递的数据。先来看一个样例:</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</div><div class="line"><span class="meta">@app.route('/register', methods=['POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></div><div class="line">    username = request.form.get(<span class="string">'username'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</div><div class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'username cannot be empty'</span>)</div><div class="line">    <span class="keyword">if</span> len(username) &gt; <span class="number">10</span>:</div><div class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'username should be less than 10'</span>)</div><div class="line">    password = request.form.get(<span class="string">'password'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> password:</div><div class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'password cannot be empty'</span>)</div><div class="line">    <span class="keyword">if</span> len(password) &lt; <span class="number">10</span>:</div><div class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'username should be longer than 10'</span>)</div><div class="line">    age = request.form.get(<span class="string">'age'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> age:</div><div class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'age should not be empty'</span>)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">      age = int(age)</div><div class="line">    <span class="keyword">except</span> (TypeError, ValueError):</div><div class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'age should be an integer'</span>)</div><div class="line">    from_ = request.args.get(<span class="string">'from'</span>)</div><div class="line">    <span class="keyword">if</span> from_ <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'qq'</span>, <span class="string">'weibo'</span>, <span class="string">'native'</span>):</div><div class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'invalid from'</span>)</div><div class="line">    <span class="keyword">if</span> from_ == <span class="string">'weibo'</span></div><div class="line">      register_weibo(username, password, age)</div><div class="line">    <span class="keyword">if</span> from_ == <span class="string">'qq'</span>:</div><div class="line">      register_qq(username, password, age)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">      register_native(username, passowrd, age)</div></pre></td></tr></table></figure>
<p>我们花费了大量的精力在获取和验证username, age, password和from_这几个字段， register的view层看上去就感觉很混乱，要改动某个字段的验证逻辑，还要在register函数 中找到对应这个字段的验证代码。有没有办法把表单验证的逻辑从视图层抽离出去，让视图层只做dispatch的工作呢？</p>
<p>有django开发经验的同学会想那就来写个middleware吧，Flask其实也提供了middleware机制， 不过这个middleware是底层werkzeug库封装的wsgi中间件，不能很好地和flask框架的上下文结合起来。 其实我们完全可以从Python语言层面触发，利用Python强大的抽象能力，用最简单的方式解决问题。对， 你是不是也想到了，Python的万金油大杀器——decorator!</p>
<p>如果能在view函数上面套一个decorator就能把表单验证的活干了，view层的代码就会轻便很多。 我们试着设计一下这个decorator的API。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> some_where <span class="keyword">import</span> form</div><div class="line"><span class="meta">@app.route('/register', methods=['POST'])</span></div><div class="line"><span class="meta">@RegisterForm</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></div><div class="line">   username = form.username</div><div class="line">   password = form.passoword</div><div class="line">   from_ = form.<span class="keyword">from</span></div><div class="line">   age = form.age</div><div class="line">   <span class="comment"># register_logic...</span></div></pre></td></tr></table></figure>
<p>我们希望通过声明式的方法来定义表单验证的逻辑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterForm</span>:</span></div><div class="line">    username = String(<span class="string">'form'</span>, required=<span class="keyword">True</span>, max_length=<span class="number">10</span>)</div><div class="line">    password = String(<span class="string">'form'</span>, required=<span class="keyword">True</span>, min_length=<span class="number">10</span>)</div><div class="line">    age = Int(<span class="string">'form'</span>, required=<span class="keyword">True</span>)</div><div class="line">    from_ = String(<span class="string">'args'</span>, required=<span class="keyword">True</span>, enums=(<span class="string">'qq'</span>, <span class="string">'weibo'</span>, <span class="string">'native'</span>))</div></pre></td></tr></table></figure>
<p><code>form</code>和<code>args</code>分别表示从formData和querystring获取数据。</p>
<p>如果我们能够实现<code>RegisterForm</code>, <code>String</code>, <code>Int</code>的功能, 让开发者只需要声明<code>RegisterForm</code>和对应的字段就能完成表单验证的工作, 那么视图层就能完全解脱出来，同时声明式的表单类也更容易维护。至少上面的register函数和RegisterForm已经非常赏心悦目了, 而且十分Pythonic。</p>
<p>Ok, 饼已经画好，现在我们来填坑吧, 整个实现的代码会用到一些比较高级的语言特性，比如descriptor和metaclass，建议读者先熟悉或温习一下相关内容。同时也会用到一些Python3 only的东西, 也许能够激发一下你对Python3的好奇心!</p>
<h2 id="Test-first"><a href="#Test-first" class="headerlink" title="Test first"></a>Test first</h2><p>虽然我不是TDD的忠实拥趸，但还是先来几个测试用例压压惊:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> flask</div><div class="line"><span class="keyword">import</span> pytest</div><div class="line"></div><div class="line"><span class="keyword">from</span> forms <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_form</span><span class="params">()</span>:</span></div><div class="line">    app = flask.Flask(__name__)</div><div class="line">    app.testing = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BasicForm</span><span class="params">(Form)</span>:</span></div><div class="line">        a = IntField(<span class="string">'args'</span>, required=<span class="keyword">True</span>, name=<span class="string">'a'</span>)</div><div class="line">        b = StringField(<span class="string">'args'</span>, required=<span class="keyword">True</span>)</div><div class="line">        c = StringField(<span class="string">'args'</span>, required=<span class="keyword">False</span>, default=<span class="string">'default'</span>)</div><div class="line">        d = FloatField(<span class="string">'args'</span>, required=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RequireForm</span><span class="params">(Form)</span>:</span></div><div class="line">        x = StringField(<span class="string">'args'</span>, required=<span class="keyword">True</span>, default=<span class="string">'default'</span>)</div><div class="line"></div><div class="line"><span class="meta">    @app.route('/')</span></div><div class="line"><span class="meta">    @BasicForm</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">assert</span> form.a == <span class="number">10</span></div><div class="line">        <span class="keyword">assert</span> form.b == <span class="string">'hello'</span></div><div class="line">        <span class="keyword">assert</span> form.c == <span class="string">'default'</span></div><div class="line">        <span class="keyword">assert</span> form.d == <span class="number">12.5</span></div><div class="line">        <span class="keyword">return</span> <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="keyword">with</span> app.test_client() <span class="keyword">as</span> c:</div><div class="line">        c.get(<span class="string">'/?a=10&amp;b=hello&amp;d=12.5'</span>)</div><div class="line"></div><div class="line"><span class="meta">    @app.route('/require')</span></div><div class="line"><span class="meta">    @RequireForm</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">require</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> str(form.x)</div><div class="line"></div><div class="line">    <span class="keyword">with</span> app.test_client() <span class="keyword">as</span> c:</div><div class="line">        <span class="keyword">with</span> pytest.raises(ValidationError):</div><div class="line">            c.get(<span class="string">'/require'</span>)</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SizeForm</span><span class="params">(Form)</span>:</span></div><div class="line">        s = IntField(<span class="string">'args'</span>, min_val=<span class="number">5</span>,max_val=<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="meta">    @app.route('/size')</span></div><div class="line"><span class="meta">    @SizeForm</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">assert</span> form.s == <span class="number">5</span></div><div class="line">        <span class="keyword">return</span> <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="keyword">with</span> app.test_client() <span class="keyword">as</span> c:</div><div class="line">        c.get(<span class="string">'/size?s=5'</span>)</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListForm</span><span class="params">(Form)</span>:</span></div><div class="line">        l = CSVListField(<span class="string">'args'</span>, each_field=IntField, description=<span class="string">'list'</span>)</div><div class="line"></div><div class="line"><span class="meta">    @app.route('/list')</span></div><div class="line"><span class="meta">    @ListForm</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list_form</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">assert</span> form.l == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="keyword">with</span> app.test_client() <span class="keyword">as</span> c:</div><div class="line">        c.get(<span class="string">'/list?l=1,2,3'</span>)</div></pre></td></tr></table></figure>
<p>实现了TDD大法的第一步<span style="color:red">red</span>，然后我们要做的就是想办法把他变<span style="color:green">绿</span>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>需要实现的Form类是一个decorator，直接作用于view函数，那么结果肯定需要一个<code>callable</code>对象， 所以需要给Form类增加一个<code>__call__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, view_func)</span>:</span></div><div class="line">        self._view_func = view_func</div><div class="line">        functools.update_wrapper(self, view_func)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._view_func(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>Ok, 看上去好像什么也没做什么的。不过还记得之前的<code>from some_where import form</code>么，这个form对象又是什么东西？怎么可以直接import进来用了，它不是全局变量么？不，你似乎忘了有一个叫做 <strong>thread(greenlet)local</strong> 的东西。Flask框架封装了threadlocal，提供了更加高级的API给开发者使用，比如<code>flask.request</code>就是一个threadlocal， 我们的form对象其实就是模拟了<code>flask.request</code>的机制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask.globals <span class="keyword">import</span> _app_ctx_stack, _app_ctx_err_msg</div><div class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_current_form</span><span class="params">()</span>:</span></div><div class="line">    top = _app_ctx_stack.top</div><div class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</div><div class="line">    <span class="keyword">return</span> getattr(top, <span class="string">'form'</span>, <span class="keyword">None</span>)</div><div class="line"></div><div class="line"></div><div class="line">form = LocalProxy(_lookup_current_form)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        _app_ctx_stack.top.form = self</div><div class="line">        <span class="keyword">return</span> self._view_func(*args, **kwargs)</div></pre></td></tr></table></figure>
<p>在调用view函数之前先把Form实例丢到app context的栈顶，<code>form = LocalProxy(_lookup_current_form)</code>里的form是一个threadlocal的全局变量，因为每个请求只会提交一个表单，所以每个请求对应了一个threadlocal的form对象， 关于flask的app context和request context，希望读者自己去做一点功课，要把所有东西都讲一遍是在太累， 所以我是假设读者具备一定的基础， 这样交流起来比较轻松一点。</p>
<p>从暴露的API看到，<code>username</code>和<code>password</code>是全局form对象的属性，怎么才能在<code>form.username</code>的时候去从request里面拿到username的数据并做玩验证最后返回这个数据呢？显然，我们需要一个拦截机制来代理对username的访问，在Python里面，最直接的方法就是通过descriptor的<code>__get__</code>方法.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">_none_value = object()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormField</span>:</span></div><div class="line">    VALID_SOURCES = (<span class="string">'args'</span>, <span class="string">'form'</span>, <span class="string">'json'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, source=<span class="string">''</span>, *, name=<span class="string">''</span>, required=True,</span></span></div><div class="line">                 default=None, description=<span class="string">''</span>):</div><div class="line">        <span class="keyword">if</span> source <span class="keyword">and</span> source <span class="keyword">not</span> <span class="keyword">in</span> self.VALID_SOURCES:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'request source %s is not valid'</span> % source)</div><div class="line">        self.source = source <span class="keyword">or</span> <span class="string">'json'</span></div><div class="line">        self.required = required</div><div class="line">        self.default = default</div><div class="line">        self.description = description</div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'form field attribute is readonly'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_request_data</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(request, self.source):</div><div class="line">            <span class="keyword">raise</span> ValidationError(</div><div class="line">                <span class="string">'%s is not a valid data source from request'</span> % self.source)</div><div class="line">        <span class="keyword">if</span> self.source == <span class="string">'json'</span> <span class="keyword">and</span> request.get_json(silent=<span class="keyword">True</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            source = <span class="string">'form'</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            source = self.source</div><div class="line">        req_data = getattr(request, source)</div><div class="line">        <span class="comment"># request.args or request.form</span></div><div class="line">        <span class="keyword">if</span> hasattr(req_data, <span class="string">'getlist'</span>):</div><div class="line">            raw = req_data.getlist(self.name)</div><div class="line">            <span class="keyword">if</span> len(raw) == <span class="number">1</span>:</div><div class="line">                <span class="keyword">return</span> raw[<span class="number">0</span>]</div><div class="line">            <span class="keyword">if</span> len(raw) == <span class="number">0</span>:</div><div class="line">                <span class="keyword">return</span> _none_value</div><div class="line">            <span class="comment"># 不支持多个值的表单字段, 请用csv代理</span></div><div class="line">            <span class="keyword">raise</span> ValidationError(</div><div class="line">                <span class="string">'multi values form field %s is not to be supported!'</span> % self.name)</div><div class="line">        <span class="comment"># request.json</span></div><div class="line">        <span class="keyword">return</span> req_data.get(self.name, _none_value)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, _)</span>:</span></div><div class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        name = self.name</div><div class="line">        data = self._get_request_data()</div><div class="line"></div><div class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> _none_value:</div><div class="line">            <span class="keyword">if</span> self.required:</div><div class="line">                <span class="keyword">raise</span> ValidationError(<span class="string">'FIELD %s is required'</span> % name)</div><div class="line">            <span class="comment"># return default directly</span></div><div class="line">            self.__dict__[name] = self.default</div><div class="line">            <span class="keyword">return</span> self.default</div><div class="line"></div><div class="line">        result = self.process(data)</div><div class="line">        self.__dict__[name] = result</div><div class="line">        <span class="keyword">return</span> result</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">return</span> data</div></pre></td></tr></table></figure></p>
<p>FormField是一个BaseClass，注意到<code>__init__</code>方法的标签了么，<code>def __init__(self, source=&#39;&#39;, *, name=&#39;&#39;...</code>中 ‘*‘ 的意思是后面的参数必须是keyword的方式传进来，<code>FormField(&#39;args&#39;, name=&#39;username&#39;)</code> is Ok while <code>FormField(&#39;args&#39;, &#39;username&#39;)</code> is not. 这个Python3的新特性带来的好处是通过将某些参数设计成keyword only的形式，使API更加清晰明了，降低了调用方错误传参的可能性。 <code>__get___</code>方法拦截了对<code>FormField</code>实例的访问，<code>_get_request_data</code>解析request来获取原始数据， <code>_none_value</code>这个哨兵表示request中找不到对应字段。解析完request之后，需要调用<code>process</code>方法来对数据做校验和转化，子类通过override这个方法来实现自己的校验逻辑。 <code>self.__dict__[name] = result</code>这一步十分tricky， 通过把结果直接放到form对象的<code>__dict__</code>属性中，下次访问同名属性的时候就直接从<code>__dict__</code>中取出返回，而不需要再走一遍descriptor的<code>__get__</code>方法了。</p>
<p>下面是子类的实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthLimitedField</span><span class="params">(FormField)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, source=<span class="string">''</span>, *, min_length=None, max_length=None, **kwargs)</span>:</span></div><div class="line">        self.min = min_length</div><div class="line">        self.max = max_length</div><div class="line">        super().__init__(source, **kwargs)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.max <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> len(data) &gt; self.max:</div><div class="line">            <span class="keyword">raise</span> ValidationError(</div><div class="line">                <span class="string">'FIELD &#123;&#125; is limited to max length &#123;&#125; but actually is &#123;&#125;'</span>.format(  <span class="comment"># noqa</span></div><div class="line">                    self.name, self.max, len(data)))</div><div class="line">        <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> len(data) &lt; self.min:</div><div class="line">            <span class="keyword">raise</span> ValidationError(</div><div class="line">                <span class="string">'FIELD &#123;&#125; is limited to min length &#123;&#125; but actually is &#123;&#125;'</span>.format(  <span class="comment"># noqa</span></div><div class="line">                    self.name, self.min, len(data)))</div><div class="line"></div><div class="line">        <span class="keyword">return</span> super().process(data)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizedField</span><span class="params">(FormField)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, source=<span class="string">''</span>, *, min_val=None, max_val=None,</span></span></div><div class="line">                 inc_min=True, inc_max=True, **kwargs):</div><div class="line">        self.min = min_val</div><div class="line">        self.max = max_val</div><div class="line">        self.inc_min = inc_min</div><div class="line">        self.inc_max = inc_max</div><div class="line">        super().__init__(source, **kwargs)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.max <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            invalid = data &gt; self.max <span class="keyword">if</span> self.inc_max <span class="keyword">else</span> data &gt;= self.max</div><div class="line">            <span class="keyword">if</span> invalid:</div><div class="line">                <span class="keyword">raise</span> ValidationError(</div><div class="line">                    <span class="string">'FIELD &#123;&#125; is limited to max value &#123;&#125; but actually is &#123;&#125;'</span>.format(</div><div class="line">                        self.name, self.max, data))</div><div class="line">        <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            invalid = data &lt; self.min <span class="keyword">if</span> self.inc_min <span class="keyword">else</span> data &lt;= self.min</div><div class="line">            <span class="keyword">if</span> invalid:</div><div class="line">                <span class="keyword">raise</span> ValidationError(</div><div class="line">                    <span class="string">'FIELD &#123;&#125; is limited to min value &#123;&#125; but actually is &#123;&#125;'</span>.format(</div><div class="line">                        self.name, self.min, data))</div><div class="line">        <span class="keyword">return</span> super().process(data)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypedField</span><span class="params">(FormField)</span>:</span></div><div class="line">    field_type = type(<span class="keyword">None</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            data = self.field_type(data)</div><div class="line">            <span class="keyword">return</span> super().process(data)</div><div class="line">        <span class="keyword">except</span> (TypeError, ValueError):</div><div class="line">            <span class="keyword">raise</span> ValidationError(</div><div class="line">                <span class="string">'FIELD &#123;&#125; cannot be converted to &#123;&#125;'</span>.format(</div><div class="line">                    self.name, self.field_type</div><div class="line">                )</div><div class="line">            )</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntField</span><span class="params">(TypedField, SizedField)</span>:</span></div><div class="line">    field_type = int</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatField</span><span class="params">(TypedField, SizedField)</span>:</span></div><div class="line">    field_type = float</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicStringField</span><span class="params">(TypedField)</span>:</span></div><div class="line">    field_type = str</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoolField</span><span class="params">(TypedField)</span>:</span></div><div class="line">    field_type = bool</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(BasicStringField, LengthLimitedField)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSVListField</span><span class="params">(FormField)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, source=<span class="string">''</span>, *, each_field, **kwargs)</span>:</span></div><div class="line">        self.each_field = each_field</div><div class="line">        super().__init__(source, **kwargs)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, data)</span>:</span></div><div class="line">        data_list = data.split(<span class="string">','</span>)</div><div class="line">        <span class="keyword">if</span> isinstance(self.each_field, FormField):</div><div class="line">            each_field = self.each_field</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            each_field = self.each_field(source=self.source)</div><div class="line">        <span class="keyword">return</span> [each_field.process(elem) <span class="keyword">for</span> elem <span class="keyword">in</span> data_list]</div></pre></td></tr></table></figure></p>
<p>上面提供了一些基本的字段类型, 拓展起来也很方便，只需要组合已有类型或者在新的类型中覆写<code>process</code>方法。 <code>super()</code>方法也是Python3 only的，我们看到<code>IntField</code>继承了TypedField和SizedField两个类，每个类的<code>process</code>方法都先做了自己的校验，然后丢给<code>super()</code>。那么TypedField和SizedField的process方法都会调用么，先调用哪一个呢？我们可以通过<code>IntField</code>的<code>__mro__</code>属性知道调用顺序。</p>
<pre><code>In [1]: IntField.__mro__
Out[1]:
(zeus.core.forms.IntField,
 zeus.core.forms.TypedField,
 zeus.core.forms.SizedField,
 zeus.core.forms.FormField,
 object)
</code></pre><p>所以调用顺序是<code>TypedField.process</code> -&gt; <code>SizedField.process</code> -&gt; <code>Form.process</code>。关于<code>mro</code>的机制，这里也不展开了。</p>
<p>还记得我们的API么，回顾一下Field的使用姿势</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterForm</span>:</span></div><div class="line">    username = StringField(<span class="string">'form'</span>, required=<span class="keyword">True</span>, max_length=<span class="number">10</span>)</div><div class="line">    password = StringField(<span class="string">'form'</span>, required=<span class="keyword">True</span>, min_length=<span class="number">10</span>)</div><div class="line">    age = IntField(<span class="string">'form'</span>, required=<span class="keyword">True</span>)</div><div class="line">    from_ = StringField(<span class="string">'args'</span>, required=<span class="keyword">True</span>, enums=(<span class="string">'qq'</span>, <span class="string">'weibo'</span>, <span class="string">'native'</span>))</div></pre></td></tr></table></figure>
<p>注意我们并没有把字段的name作为参数传入， 那么FormField又怎么知道字段的名字是什么呢? 又到了使用黑膜法的时候，虽然我一再承诺不率先使用metaclass。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormFieldMeta</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="keyword">for</span> field, value <span class="keyword">in</span> attrs.items():</div><div class="line">            <span class="keyword">if</span> isinstance(value, FormField):</div><div class="line">                value.name = field</div><div class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span><span class="params">(metaclass=FormFieldMeta)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, view_func)</span>:</span></div><div class="line">        self._view_func = view_func</div><div class="line">        functools.update_wrapper(self, view_func)</div></pre></td></tr></table></figure></p>
<p><code>FormFieldMeta</code>在<code>Form</code>类创建的时候，遍历了<code>Form</code>的属性，如果发现<code>FormField</code>就把对应的属性名设为<code>FormField</code>的name字段，所以千万别以为metaclass有多高深，其实是很简单的玩儿。（当然我假设你有了解过metaclass的原理）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Congrats! We’are done! 我们实现了一个声明式的基于decorator的flask表单验证模块。你可以试试现在再跑一下之前的测试用例。相关代码请参考<a href="https://github.com/moonshadow/way-to-python-ninja/tree/master/advanced-flask/form" target="_blank" rel="external">flask form</a>。 如果测试通过，接下来就可以走TDD的第三步——refactor了, enjoy yourself!。</p>
<p>回顾一下，为了实现这个模块，我们用到了decorator，descriptor， metaclass，keyword only argument, 多重继承，mro, flask的context global… 庆祝一下我们的成果吧！如果你对整个模块的实现都已经了然于胸，恭喜你，You’are a Python veteran now! 如果你还有很多困惑或者感觉举步维艰，也不要着急，把每个点的功课一个一个做好，多动脑筋思考, 试着以理解这个模块为目标好好地学一波Python吧, it deserves! I promise。</p>
<p>Anyway, 如果你有更好的设计或者更加优雅的实现，不妨也拿出来分享一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;用Flask框架开发web应用的过程中，我们通常会在视图层写很多繁琐的代码来校验表单的数据，同时把提交的数据转换成业务需要的格式, 结果就是视图层的代码到处夹杂着表单验证的逻辑，显得错综复杂，难以维护。注意我所指的表单是更加广义的概念，包括query string或者通过设置Content-Type为&lt;code&gt;application/json&lt;/code&gt;传递的数据。先来看一个样例:&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://imiliya.com/categories/Programming/"/>
    
    
      <category term="Python" scheme="http://imiliya.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://imiliya.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>An Introduction to Python C Extension Programming (Part2)</title>
    <link href="http://imiliya.com/2016/08/19/py-c-ext-part2/"/>
    <id>http://imiliya.com/2016/08/19/py-c-ext-part2/</id>
    <published>2016-08-18T17:06:53.000Z</published>
    <updated>2016-08-19T16:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>TL; DR.</p>
<h2 id="什么是Python-C-Extension？"><a href="#什么是Python-C-Extension？" class="headerlink" title="什么是Python C Extension？"></a>什么是Python C Extension？</h2><p>所谓<a href="https://docs.python.org/3/extending/extending.html" target="_blank" rel="external">Python C Extension</a>， 是指在CPython平台上面,遵循Python C Extension Interface写出来的c代码模块，经过编译后可以在Python代码中直接import，相当于一个Python Module。 通俗的讲，就是用C语言实现一个library，然后给这个library披一个Python模块的皮，好让Python程序像import其他普通Python模块一样来使用这个C library.</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>我们直接看官方文档的例子来写一个extension 模块吧(偷个懒，这篇文章我就当官方文档的搬运工了)。</p>
<p>创建<code>main.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> spam</div><div class="line"></div><div class="line">status = spam.system(<span class="string">'ls -l'</span>)</div></pre></td></tr></table></figure>
<p>spam是我们将要实现的Extension模块, 使用方式很简单，直接import就行了。</p>
<p>然后我们来实现这个模块。</p>
<a id="more"></a>
<p>创建<code>spam.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> PyObject *SpamError;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> PyObject *<span class="title">spam_system</span><span class="params">(PyObject *self, PyObject *args)</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *command;</div><div class="line">  <span class="keyword">int</span> sts;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">"s"</span>, &amp;command))</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">   sts = system(command);</div><div class="line">   <span class="keyword">if</span> (sts &lt; <span class="number">0</span>) &#123;</div><div class="line">    PyErr_SetString(SpamError, <span class="string">"System command failed"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> PyLong_FromLong(sts);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> PyMethodDef SpamMethods[] = &#123;</div><div class="line">    &#123;<span class="string">"system"</span>, spam_system, METH_VARARGS, <span class="string">"Execute a shell command."</span>&#125;,</div><div class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> PyModuleDef spammodule = &#123;</div><div class="line">    PyModuleDef_HEAD_INIT,</div><div class="line">    <span class="string">"spam"</span>,</div><div class="line">    <span class="string">"spam document"</span>,</div><div class="line">    <span class="number">-1</span>,</div><div class="line">    SpamMethods</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_spam</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    PyObject *m;</div><div class="line"></div><div class="line">    m = PyModule_Create(&amp;spammodule);</div><div class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    SpamError = PyErr_NewException(<span class="string">"spam.error"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Py_INCREF(SpamError);</div><div class="line">    PyModule_AddObject(m, <span class="string">"error"</span>, SpamError);</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>WTF, 都是些什么鬼玩意儿?</p>
<p><code>#include &lt;Python.h&gt;</code> 引入了Python C API的header文件，这样在<code>spam.c</code> 中就可以使用Python.h里面定义的结构， 函数和宏了，<code>Python.h</code>把<code>&lt;stdio.h&gt;, &lt;string.h&gt;, &lt;errno.h&gt;,&lt;stdlib.h&gt;</code>这些标准库的header都已经include了进来。 如果对Python.h里面的东西感兴趣, 在终端跑一下<code>python3-config --cflags</code>, 就能找到文件的位置。</p>
<pre><code>python3-config --cflags
</code></pre><p>在运行结果中找到header的路径(Mac)。</p>
<pre><code>-I/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/include/python3.5m
</code></pre><p>直接cd到<code>/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/include/python3.5m</code>目录就能找到这个header文件, Python源码的其他header文件也都在这里了。</p>
<p><code>static PyObject *SpamError</code>定义了一个SpamError对象, 根据名字可以猜到这将是一个异常类。Python的所有对象对应的都是一个<code>PyObject</code>的结构， 你可以到object.h头文件里面看看PyObject是怎么定义的，不过只能看得一脸懵逼就是了，如果对Python源码好奇，墙裂推荐《Python源码剖析》这本书。 .</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static PyObject *spam_system(PyObject *self, PyObject *<span class="keyword">args</span>) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *command;</div><div class="line">  int <span class="keyword">sts</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!PyArg_ParseTuple(<span class="keyword">args</span>, <span class="string">"s"</span>, &amp;command))</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">   <span class="keyword">sts</span> = system(command);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">sts</span> &lt; 0) &#123;</div><div class="line">    PyErr_SetString(SpamError, <span class="string">"System command failed"</span>);</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> PyLong_FromLong(<span class="keyword">sts</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>spam_system</code>定义了一个静态函数。 <code>self</code>指向的是当前模块，<code>args</code>则是Python调用这个方法时传入的参数.<br><code>PyArg_ParseTuple</code>把<code>args</code>解析成c字符串, 并让command指向这个字符串的地址， 然后调用std的system函数(通过include引入的)。 sts保存了系统调用的返回值，<code>sts &lt; 0</code> 说明调用失败，通过<code>PyErr_SetString</code> 设置异常信息，否则<code>PyLong_FromLong</code>将返回值转换为Python 的int对象.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> PyMethodDef SpamMethods[] = &#123;</div><div class="line">    &#123;<span class="string">"system"</span>, spam_system, METH_VARARGS, <span class="string">"Execute a shell command."</span>&#125;,</div><div class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SpamMethods是模块的成员方法列表，其实就是一个数组, 每个元素都是一个<em>PyMethodDef</em>的结果表示一个模块的一个成员方法. <code>system</code>是最后输出的变量名， spam_system是刚才定义的函数， _METH<em>VARARGS</em>表示Python调用这个函数是传参的方式。 <code>&quot;Execute s shell command&quot;</code> 是函数的注释信息. <code>{NULL, NULL, 0, NULL}</code> 起一个哨兵的作用，这样模块遍历<em>SpamMethods</em>到这里就知道所有成员都已经被定义了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> PyModuleDef spammodule = &#123;</div><div class="line">    PyModuleDef_HEAD_INIT,</div><div class="line">    <span class="string">"spam"</span>,</div><div class="line">    <span class="string">"spam document"</span>,</div><div class="line">    <span class="number">-1</span>,</div><div class="line">    SpamMethods</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义了将要输出的模块对象, 这是一个<code>PyModuleDef</code>结构，spamMethods对应了上面定义的成员数组。 最后我们还需要定义模块的初始化方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_spam</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    PyObject *m;</div><div class="line"></div><div class="line">    m = PyModule_Create(&amp;spammodule);</div><div class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    SpamError = PyErr_NewException(<span class="string">"spam.error"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Py_INCREF(SpamError);</div><div class="line">    PyModule_AddObject(m, <span class="string">"error"</span>, SpamError);</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>import spam</code> 的时候，Python C Extension的模块机制就会执行PyInt_spam函数来创建并初始化模块, 初始化过程中还会创建SpamError类并添加到spam模块的成员变量中, Py_INCREF增加一个SpamError的引用计数(后面会讲到Python 的reference counting).</p>
<p>至此spam模块的实现就算大功告成， 我们需要把他编译成可以直接import的模块. 手动编译设置各种参数比较麻烦，可以利用<code>distutils</code>里面的方法来构建.</p>
<p>创建setup.py</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from distutils.core <span class="keyword">import</span> <span class="built_in">setup</span>, Extension</div><div class="line"></div><div class="line"><span class="built_in">setup</span>(name=<span class="string">'sample'</span>, ext_modules=[</div><div class="line">    Extension(<span class="string">'spam'</span>, [<span class="string">'spam.c'</span>])</div><div class="line">])</div></pre></td></tr></table></figure>
<p>注意Extension的<code>__init__</code>方法第一个参数指定了模块名为spam， 需要和模块初始化PyInit_spam中的spam保持一致， import spam的运行时，会根据这个参数的名字，去调用对应PyInit_name的方法。</p>
<p>运行</p>
<pre><code>python3 setup.py build_ext --inplace
</code></pre><p>会把spam.c编译成对应的dll模块，<code>inplace</code> 选项指定了结果文件的位置是当前目录.</p>
<p>跑一下我们的<code>main.py</code></p>
<pre><code>python3 main.py
</code></pre><p>结果会在终端打印当前目录下的文件。</p>
<p>如果想安装到site-packages下面， 运行<code>python3 setup.py install</code>， 然后就可以在其他项目也能直接import spam模块了。</p>
<p><em>Extension</em> 类的 <em>__init__</em> 方法还接受很多其他的参数: <em>include_dirs</em> 指定包含头文件的路径， <em>define_macros</em> 定义一些宏，<em>library_dirs</em> 指定动态链接的目录, 相当于gcc的 <em>-L</em> 选项，libraries 指定链接的库，相当与gcc的 <em>-l</em> 选项。还有其他一些参数读者请自行参考<a href="https://docs.python.org/3.5/distutils/apiref.html#distutils.core.Extension" target="_blank" rel="external">distutils</a>。</p>
<h2 id="错误和异常-Errors-and-Exception"><a href="#错误和异常-Errors-and-Exception" class="headerlink" title="错误和异常(Errors and Exception)"></a>错误和异常(Errors and Exception)</h2><p>Python解释器有一个不成文的规定， 当函数失败的时候，需要设置一个异常信息，并且返回错误值，异常信息保存在解释器的一个静态全局变量中。如果这个变量的值为NULL(空指针)，说明没有异常发生。除此之外还有两个全局变量，一个保存了异常信息对应的描述，另一个保存了发生异常时的整个调用堆栈, 它们对应了sys.exc_info()结果的三个元素。</p>
<p>前面用到的PyErr_SetString()方法，第一个参数就是我们定义的异常类对象,第二个参数是关联的异常信息描述。 <em>PyErr_SetString(SpamError, “System command failed”)</em> 设置了全局的异常信息,Python解释器发现这个异常信息的时候，会跳转到异常处理流程(如果想了解Python解释器是怎么运作的, 异常机制又是如何实现的，再次推荐《Python源码剖析》这本书)。</p>
<h2 id="一点题外话——引用计数-Reference-Counts"><a href="#一点题外话——引用计数-Reference-Counts" class="headerlink" title="一点题外话——引用计数(Reference Counts)"></a>一点题外话——引用计数(Reference Counts)</h2><p>C和C++要求程序员负责动态的分配和回收堆上的内存，C语言提供了malloc()和free()函数(C++对应有new和delete操作符)。</p>
<p>每一个malloc()分配的内存资源， 最终都需要通过调用free()来回收, 如果忘记了free， 被分配的内存资源直到进程退出都无法重新利用，这就是所谓的内存泄漏(memory leak)。如果继续使用free()过的内存， 很有可能和以后通过malloc()重新分配的内存资源冲突，会造成同引用没有初始化的指针一样的结果，core dumps, 错误的结果，进程莫名崩溃之类。</p>
<p>常见的内存泄露都是程序忘记调用free造成的，比如错误处理的逻辑中直接return却没有free之前分配的内存，尤其是代码量比较大的时候很容易出现。如果某个有内存泄露的函数被大量的调用，那么每次调用都会造成一定的内存泄漏, 如果只是短暂运行的进程，随着进程结束，这些资源都会被操作系统回收。但是如果是长时间运行的进程（比如一个后台daemon)，没有回收的内存资源会随着程序运行时间的增加而增加，最终把系统资源耗尽，程序崩溃。 所以通过一个好的编码规范避免内存泄露就显得十分重要。</p>
<p>Python大量的使用了malloc和free来管理内存，就必须有一个好的策略来避免上面提到的问题。Python使用的主要方法是 <em>reference counting</em>(引用计数) . 简单地讲， 每一个对象都有一个引用计数器，每当有新的引用，计数器的值+1, 如果引用被删除，计数器的值就-1，当计数器的值减到0，这个对象占用的内存就可以回收了。</p>
<p>引用计数不能解决循环引用的问题，循环引用是指存在互相引用的对象，引用计数永远不可能减到0, 我们来看一个粗暴的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gc</div><div class="line">gc.disable() <span class="comment"># 关闭gc功能</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">  a = [<span class="number">1</span>] * <span class="number">1000000</span></div><div class="line">  b = [<span class="number">1</span>] * <span class="number">1000000</span></div><div class="line">  a.append(b)</div><div class="line">  b.append(a)</div><div class="line">  <span class="keyword">del</span> a</div><div class="line">  <span class="keyword">del</span> b</div></pre></td></tr></table></figure>
<p><strong>友情提示</strong>  千万不要手贱运行上面的代码!! 对于不听劝告的小朋友，如果造成无法挽回的后果本人表示不负任何责任。</p>
<p><code>del a</code>和<code>del b</code>后，我们的程序已经没有对这两个对象的引用了，但是b和a还是互相引用了对象，他们的refcount都是1，那么引用计数机制就永远不会去回收a和b的内存, 每个While循环都会出现一次循环引用，这个程序会迅速蚕食掉你的内存。</p>
<p> Python通过一个叫做<a href="https://en.wikipedia.org/wiki/Cycle_detection" target="_blank" rel="external">cycle detector</a>的技术解决了这个问题，<a href="https://docs.python.org/3/library/gc.html#module-gc" target="_blank" rel="external">gc</a>模块甚至提供了collect方法让程序员自己手动处理循环引用。如果你能保证你的Python代码不会出现循环引用的情况，可以通过<code>--without-cycle-gc</code>这个启动选项关掉自动回收的功能, 不过不建议这么做，Why bothering your self if Python could handle it for you?</p>
<p>也许你可以试试把上面的<code>gc.disable()</code>这一行注释掉再运行这段代码。  Please be very very careful!</p>
<p>Python通过引用计数和垃圾回收，实现了内存的自动管理，把Python程序员从手动内存管理的负担重解脱了出来，下面我们来看看Python的引用计数是具体是怎么玩的。</p>
<h3 id="Reference-Counting-in-Python"><a href="#Reference-Counting-in-Python" class="headerlink" title="Reference Counting in Python"></a>Reference Counting in Python</h3><p>Note:  下面提到<code>ref</code>, <code>reference</code>, <code>引用</code>这三个词没有什么区别。</p>
<p>Python通过两个宏 Py_INCREF(x) and Py_DECREF(x)来操作对象的引用计数。问题是这两个宏都需要在什么时候去调用呢？</p>
<p>Python的API文档中介绍了几个术语。</p>
<ul>
<li><p><strong>own</strong>: 一个对象有很多个reference，每个reference对应会有一个owner， 一个对象的引用计数就是owner的个数. owner可以通过传递， 保存，或者直接Py_DECREF()来放弃对这个对象的reference。</p>
</li>
<li><p><strong>borrow</strong>:  并不own一个reference，不会增加对象的引用计数，因此也不需要调用Py_DECREF, 如果对一个borrow的reference调用了Py_INCREF， 就把他变成了一个owner。</p>
</li>
</ul>
<p>当一个对象的引用作为参数传入函数或者作为函数的返回结果时， 根据函数的接口定义，我们可以知道对应ownership有没有被转移。</p>
<p>大多数返回一个引用的函数会把ownership交给调用者， 一般的如果函数创建了新的对象并返回对这个对象的引用，比如PyLong_FromLong(), Py_BuildValue, 那么这个引用的ownership转给了调用者。例外的是 PyTuple_GetItem(), PyList_GetItem(), PyDict_GetItem(), and PyDict_GetItemString()这些函数，只是返回一个borrowed引用。</p>
<p>当对象引用作为参数传入函数的时候，一般情况下函数都是borrow了这个reference，并不增加引用计数，如果函数需要增加引用计数，需要显示调用Py_INCREF。 不过也有例外， PyTuple_SetItem() and PyList_SetItem()这两个函数就接管了引用成为owner。</p>
<p>是不是感觉很抽象(反正我刚开始的时候就是一脸懵逼), 为什么一会儿要borrow一会儿要own的…下面举几个例子来分析一下你应该就能稍微明白一点了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PyList_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    PyList_SetItem(<span class="built_in">list</span>, <span class="number">1</span>, PyLong_FromLong(<span class="number">0L</span>));</div><div class="line">    PyObject_Print(item, <span class="built_in">stdout</span>, <span class="number">0</span>); <span class="comment">/* BUG! */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PyList_GetItem返回了list第一个元素的引用，根据<a href="https://docs.python.org/3.5/c-api/list.html#c.PyList_GetItem" target="_blank" rel="external">PyList_GetItem</a>的文档我们知道这个函数返回的是一个borrowed引用, 也就是说不会增加list[0]这个元素的引用计数（我们假设现在list[0],list[1]的refcount都是1), 接下来我们设置list[1]元素的值为0(新创建的int对象)，而原先的list[1]引用的对象的refcount就会减1变成0，这个时候 原先list[1]对象的<a href="https://docs.python.org/3/reference/datamodel.html#object.__del__" target="_blank" rel="external"><code>__del__</code></a>就会被调用，而<code>__del__</code>方法可以直接访问list[0]的元素，如果在里面调用del list[0], list[0]元素的引用计数也减为0了，PyObject_Print函数就会访问到一个已经被回收的内存地址, 下面是模拟这个场景的python代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">list0 = object()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">del</span> list0</div><div class="line"></div><div class="line">list1 = Obj()</div><div class="line">l = [list0, list1]</div></pre></td></tr></table></figure></p>
<p>所以如果是borrow一个引用的话，必须保证在使用这个引用的过程中这个引用对象的refcount不会减为0, 修改前面的C代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">no_bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PyList_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    Py_INCREF(item);</div><div class="line">    PyList_SetItem(<span class="built_in">list</span>, <span class="number">1</span>, PyLong_FromLong(<span class="number">0L</span>));</div><div class="line">    PyObject_Print(item, <span class="built_in">stdout</span>, <span class="number">0</span>);</div><div class="line">    Py_DECREF(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在PyList_SetItem之前增加item对象引用计数，保证了PyObject_Print访问到的item的有效性。</p>
<p>或者使用<a href="https://docs.python.org/3.5/c-api/sequence.html#c.PySequence_GetItem" target="_blank" rel="external">PySequence_GetItem</a>方法，查看文档我们发现这个函数返回的是一个owner reference，增加了一个对对应元素对象的引用计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">no_bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PySequence_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line">    PyList_SetItem(<span class="built_in">list</span>, <span class="number">1</span>, PyLong_FromLong(<span class="number">0L</span>));</div><div class="line">    PyObject_Print(item, <span class="built_in">stdout</span>, <span class="number">0</span>);</div><div class="line">    Py_DECREF(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要用完之后调用Py_DECREF来去掉刚才增加的引用计数, 但是值得注意的是PySequence_GetItem既然返回的是一个owner, 那么用这个它的目的就是要长时间占用的，而不是像上面这样只是print一下, 这个地方用PySequence_GetItem其实已经失去本意了, 用PyList_GetItem暂时borrow一下是更加正确的选择。</p>
<p>所以你发现borrow和own的区别了么? borrow过来reference的不会占用一个计数，在使用borrow的引用过程中必须要自己保证引用有效，如果可以保证中间没有操作可能减少这个引用计数的话，我们甚至省去了INC和DEC引用的烦恼，所谓borrow就是我借过来用一下，等下肯定会还你的。这个比喻其实有一点不恰当的地方，因为borrow的reference其实也被借出方占着的，比如上面的list也还是可以访问item对象，借的过程中借用方甚至还要担心被借走的东西被已经被处理掉的可能（PyList_SetItem）， 这其实就不叫借了吧，还不如说是暂时share给你一会儿，虽然你也能用，但是别人问起来你得说这个东西你并没有所有权, 而且share给你的人心情不好把东西给卖了你就用不了了，这个时候Py_INCREF就好像在说你先别卖啊，我还没用完呢，Py_DECREF则是说我现在已经不用了，你爱怎么玩怎么玩。own就不一样了，如果我们两个都own了一个东西，那么光你说卖还不成，你只能说自己不要了（像del list0)那样，但是我还占着一份呢，Py_DECREF则是说现在我也不想要了——喂，那个捡垃圾的(item的 <code>__del__</code> 方法)，你来拿走吧。 不知道这样表述清不清楚。</p>
<p>对于上面的例子，Python的GIL保证了这个函数调用过程不会被其他线程打断,因此我们不必担心被borrow的引用item在另一个线程被回收了（比如在另一个thread调用了PyList_SetItem，里面又做了减少item引用计数的事情（论GIL的重要性). 但是python提供了Py_BEGIN_ALLOW_THREADS这个宏来暂时解除全局锁，看看下面的这个代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PyList_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line">    Py_BEGIN_ALLOW_THREADS</div><div class="line">    ...some blocking I/O call...</div><div class="line">    <span class="function">Py_END_ALLOW_THREADS</span></div><div class="line">    <span class="title">PyObject_Print</span><span class="params">(item, <span class="built_in">stdout</span>, <span class="number">0</span>)</span>; <span class="comment">/* BUG! */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Py_BEGIN_ALLOW_THREADS和Py_END_ALLOW_THREADS之间，GIL被释放了，于是item就有可能在另一个线程被回收掉，后面在执行 PyObject_Print就可能产生意想不到的bug!</p>
<p>用borrow还是own其实并没有明确的规定，取决于那个模型在特定场景下使用更加方便，我们可以通过官方文档知道某个Python C API的函数具体用的borrow还是own。</p>
<p>讲了这么多引用计数的东西好像已经偏题了, 看得出来在C Extension里面对引用计数的处理也是一件比较tricky的事情。如果你对这块很感兴趣，直接阅读<a href="https://docs.python.org/3/extending/extending.html" target="_blank" rel="external">官方文档</a>是一个不错的选择, 这篇文章<a href="http://edcjones.tripod.com/refcount.html" target="_blank" rel="external">http://edcjones.tripod.com/refcount.html</a>则做了一定的解释和补充。 please keep reading patiently!</p>
<p>如果你对 <em>borrow</em>，<em>own</em> 这一块很感兴趣 ,隔壁有一门叫做<a href="https://doc.rust-lang.org/book/ownership.html" target="_blank" rel="external">Rust</a>的语言值得尝试, 可以看看它的 <em>ownership system</em> 是怎么玩的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的讲, 实现一个C Extension模块要做好三件事情</p>
<ol>
<li>满足C Extension接口的规范</li>
<li>处理好数据在Python和C之间的转化</li>
<li>用C语言实现具体的功能（或者调用已有的库)</li>
</ol>
<p>再回顾一下我们的spam.c文件，所有变量的定义都是static的，表示这些变量的作用域仅限于<code>spam.c</code>，起到了限制作用域的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SpamError = PyErr_NewException(<span class="string">"spam.error"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">Py_INCREF(SpamError);</div><div class="line">PyModule_AddObject(m, <span class="string">"error"</span>, SpamError);</div></pre></td></tr></table></figure>
<p>因为<a href="https://docs.python.org/3.5/c-api/module.html#c.PyModule_AddObject" target="_blank" rel="external">PyModule_AddObject</a>不会增加SpamError的引用计数,官方的话叫steal the reference, 如果我们不手动INC一下，那么以后删除了m.error这个属性的话，SpamError的计数就变0，对应的内存被回收，如果后面又抛出了这个异常救护出现意想不到的错误。</p>
<p>PyArg_ParseTuple的format参数格式请参考<a href="https://docs.python.org/3/c-api/arg.html" target="_blank" rel="external">PyArg_ParseTuple</a>, 与之对应的还有<code>Py_BuildValue</code> 函数， 用来构造Python对象.</p>
<p><a href="https://github.com/moonshadow/way-to-python-ninja/tree/master/python-c-ext/impl-python-c-ext" target="_blank" rel="external">相关代码</a></p>
<p>Anyway, 手动实现一个Python C Extension始终是一件很麻烦的事(还要了解Python的引用计数是怎么玩的)。如果只是简单系统调用，用<code>ctypes</code>就能直接搞定， 那专心写好C代码，然后直接让Python像用普通模块一样把它用起来岂不是更加方便？ 下一篇我们就来看看一个叫做CFFI的第三方库又是怎么实现在Python中调用C语言库的吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TL; DR.&lt;/p&gt;
&lt;h2 id=&quot;什么是Python-C-Extension？&quot;&gt;&lt;a href=&quot;#什么是Python-C-Extension？&quot; class=&quot;headerlink&quot; title=&quot;什么是Python C Extension？&quot;&gt;&lt;/a&gt;什么是Python C Extension？&lt;/h2&gt;&lt;p&gt;所谓&lt;a href=&quot;https://docs.python.org/3/extending/extending.html&quot;&gt;Python C Extension&lt;/a&gt;， 是指在CPython平台上面,遵循Python C Extension Interface写出来的c代码模块，经过编译后可以在Python代码中直接import，相当于一个Python Module。 通俗的讲，就是用C语言实现一个library，然后给这个library披一个Python模块的皮，好让Python程序像import其他普通Python模块一样来使用这个C library.&lt;/p&gt;
&lt;h2 id=&quot;简单实现&quot;&gt;&lt;a href=&quot;#简单实现&quot; class=&quot;headerlink&quot; title=&quot;简单实现&quot;&gt;&lt;/a&gt;简单实现&lt;/h2&gt;&lt;p&gt;我们直接看官方文档的例子来写一个extension 模块吧(偷个懒，这篇文章我就当官方文档的搬运工了)。&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;main.py&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; spam&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;status = spam.system(&lt;span class=&quot;string&quot;&gt;&#39;ls -l&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;spam是我们将要实现的Extension模块, 使用方式很简单，直接import就行了。&lt;/p&gt;
&lt;p&gt;然后我们来实现这个模块。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://imiliya.com/categories/Programming/"/>
    
    
      <category term="Python" scheme="http://imiliya.com/tags/Python/"/>
    
      <category term="C" scheme="http://imiliya.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>An Introduction to Python C Extension Programming (Part1)</title>
    <link href="http://imiliya.com/2016/08/16/py-c-ext-part1/"/>
    <id>http://imiliya.com/2016/08/16/py-c-ext-part1/</id>
    <published>2016-08-16T00:45:36.000Z</published>
    <updated>2016-08-18T18:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写博客的动机"><a href="#写博客的动机" class="headerlink" title="写博客的动机"></a>写博客的动机</h2><p>当了这么久的程序员，中间有好几次也想过开个博客写点什么。可是一来觉得自己太菜，再又实在过于怠惰，计划就搁置一旁(买了个域名躺了一年😂)。 然而一直以来看了各路大侠的博客，偷偷学到不少东西, 感觉好像也没那么菜了，也觉着应该把自己的一些想法和见解分享出去，回馈社会, 而不是在自己的脑子里面憋着， 即使被打脸也算是又学到了嘛, 何乐而不为。</p>
<p>在下一介Python程序员, 而且是<em>真のPython粉</em>，那就从Python写起吧, 也比较得心应手一点。现今市面上充斥各种Python教程(Python也真是太简单易上手了), 我就不去凑这个热闹也讲些Python基础或者<em>tips</em>什么的了。将要讲到的内容都是面向至少中级的Python程序员的. 所以读者最好是具备一定的Python水平，如果是刚入门的小朋友, 至少先买两本入门教程撸一遍再来吧，请点击右上角不送。</p>
<p>暂定的系列有</p>
<ol>
<li>Python C Extension</li>
<li>Profile</li>
<li>Debugging</li>
<li>Python2 or Python3</li>
<li>Unicode</li>
<li>AsyncIO</li>
<li>Modules</li>
<li>Logging</li>
</ol>
<a id="more"></a>
<h2 id="First-of-first-Python-C-Extension"><a href="#First-of-first-Python-C-Extension" class="headerlink" title="First of first (Python C Extension)"></a>First of first (Python C Extension)</h2><p>不知道大家觉得Python最神秘的地方在哪里。反正在我的经验看来，最搞不清扯不明的地方就是所谓的Python C Extension Module了。ctypes， cffi， swig， cython, numba这些名词，听上去就觉得好可怕, 想搜个像样子的介绍文章出来都难, 直接看官方文档吧有感觉有点overwhelming. 所以我希望通过C Extension这个系列的文章，把这些玩意儿一个一个都探索一下。 本人C语言水平有限，如果有胡说八道的地方， 欢迎指正，大家一起学习进步😀。 以后所有文章只针对Python3，关于<em>Python2 or Python3</em>, 以后也会找机会讨论一下, 如果有必要联系Python2的相关知识我会专门指出, 文中所有涉及到编译c代码的地方都假设读者使用的是类unix的操作系统(原因是我对windows的生态系统实在一无所知)。</p>
<h2 id="why-C"><a href="#why-C" class="headerlink" title="why C?"></a>why C?</h2><p>好吧，我们用Python是因为它很高的抽象层次，可以帮助我们迅速的构建应用，不论是写一个简单的任务脚本还是搭一个小型网站，Python都是上佳选择。然而世上没有免费午餐，开发效率的代价是牺牲了软件性能，不过一般情况下这都不是事，比如Python构建的web app性能瓶颈大多都在IO，这是没法在代码层面优化的, 可以通过改变IO模型或者扩容服务器来解决。而且一般的Python程序员习惯了Python的简介优雅，可能对性能什么的没什么概念。不过夜路走多了总会撞鬼，平常没有意识，真正性能出现问题需要优化的时候只能是一脸懵逼。如果能够具备一定的性能意识，在需要的时候知道有哪些办法可以选择和尝试，那么至少是走在了正确的道路上。性能Profile也是一个大的话题，以后再展开。</p>
<p>学习C Extension Programming也能加深对Python语言本身的理解， 对于写出更高质量的Python代码也是很有帮助的。 所以废话不多说，进入第一个话题，如何在Python代码里面调用C函数.</p>
<h2 id="How-to-call-C-function-in-Python-code"><a href="#How-to-call-C-function-in-Python-code" class="headerlink" title="How to call C function in Python code?"></a>How to call C function in Python code?</h2><p>python标准库提供了<a href="https://docs.python.org/3.5/library/ctypes.html#module-ctypes" target="_blank" rel="external"><strong>ctypes</strong></a>模块, 可以帮助我们把DLL或者shared libraries(共享库)中的函数封装成可以直接调用的Python函数。如果发现需要的某个工具已经有C语言的library, 我们就不需要重新用Python实现相同功能的模块， 既保证了效率还能省去性能的烦恼。下面是一个简单的例子:</p>
<p>首先我们创建一个C文件<code>utils.c</code>, 定义factorial和swap两个函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> factorial(x<span class="number">-1</span>) * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> temp = *a;</div><div class="line">  *a = *b;</div><div class="line">  *b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后编译成目标文件<code>utils.o</code>(我用的是Mac下面的LLVM编译器）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c -Wall -Werror utils.c</div></pre></td></tr></table></figure>
<p>再把刚生成的目标文件转化成动态链接库.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libutils</span><span class="selector-class">.so</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></div></pre></td></tr></table></figure>
<p>我们需要做的就是在<em>Python</em>代码中调用刚才在<code>utils.c</code>中定义的两个函数. 下面示例如何用<em>ctypes</em>来操作，创建文件<code>main.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ctypes</div><div class="line"></div><div class="line"></div><div class="line">utils = ctypes.cdll.LoadLibrary(<span class="string">'./libutils.so'</span>)</div><div class="line"></div><div class="line">factorial = utils.factorial</div><div class="line">factorial.argtypes = (ctypes.c_int,)</div><div class="line">factorial.restype = ctypes.c_int</div><div class="line"></div><div class="line">_swap  = utils.swap</div><div class="line">_swap.argtypes = (ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(x, y)</span>:</span></div><div class="line">    a = ctypes.c_int(x)</div><div class="line">    b = ctypes.c_int(y)</div><div class="line">    _swap(a, b)</div><div class="line">    <span class="keyword">return</span> a.value, b.value</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    print(<span class="string">'factorial of 4 is %s !'</span> % factorial(<span class="number">4</span>))</div><div class="line">    print(<span class="string">'factorial of 5 is %s !'</span> % factorial(<span class="number">5</span>))</div><div class="line"></div><div class="line">    x, y = <span class="number">10</span>, <span class="number">20</span></div><div class="line">    print(<span class="string">'x is %s and y is %s'</span> % (x, y))</div><div class="line">    x, y = swap(x, y)</div><div class="line">    print(<span class="string">'after swap'</span>)</div><div class="line">    print(<span class="string">'x is %s and y is %s'</span> % (x, y))</div></pre></td></tr></table></figure>
<p><code>utils = ctypes.cdll.LoadLibrary(&#39;./libutils.so&#39;)</code> 载入了已经编译好的<code>libutils.so</code>, factorial和swap两个函数变成了模块的locals.（如果不是自己编译的模块而是想用系统的C语言共享库，参考<code>cypes.utils</code>的<code>find_library</code>方法，路径通常都是<code>/usr/lib</code> 和 <code>/usr/local/lib</code>， linux操作系统默认都是<em>libxxx.so</em>的格式， 而os x则是<em>libxxx.dylib</em>)</p>
<p>对于<code>factorial</code>函数，只需要把python的int对象转换成对应的ctype类型再传入factorial函数， 同时需要定义返回的结果类型，把factorial函数返回的int转换成Python的int对象</p>
<p><code>swap</code>函数稍微麻烦一点，因为Python不能直接访问指针，所以需要把已有的c函数稍微做个封装， 不过思路一样就是了.</p>
<p>最后验证一下结果。<br>运行</p>
<pre><code>python3 main.py
</code></pre><p>终端输出</p>
<pre><code>factorial of 4 is 24 !
factorial of 5 is 120 !
x is 10 and y is 20
after swap
x is 20 and y is 10
</code></pre><p>Perfect! 简单的几个步骤，我们就实现了在Python中调用c函数.</p>
<p>顺便我们对比一下C语言实现的factorial和Python版本的性能,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ctypes</div><div class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</div><div class="line"></div><div class="line"></div><div class="line">utils = ctypes.cdll.LoadLibrary(<span class="string">'./libutils.so'</span>)</div><div class="line"></div><div class="line">factorial = utils.factorial</div><div class="line">factorial.argtypes = (ctypes.c_int,)</div><div class="line">factorial.restype = ctypes.c_int</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">py_factorial</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">assert</span> isinstance(n, int)</div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> py_factorial(n<span class="number">-1</span>) * n</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    number = <span class="number">100000</span></div><div class="line">    print(<span class="string">'Python 版本100000次的factorial(10)时间'</span>)</div><div class="line">    print(timeit(<span class="string">'py_factorial(10)'</span>, number=number, globals=globals()))</div><div class="line">    print(<span class="string">'C 版本100000次的factorial(10)时间'</span>)</div><div class="line">    print(timeit(<span class="string">'factorial(10)'</span>, number=number, globals=globals()))</div></pre></td></tr></table></figure>
<p>保存到<code>benchmark.py</code></p>
<p>在我的机器上运行的结果是</p>
<pre><code>Python 版本100000次的factorial(10)时间
0.3275668309943285
C 版本100000次的factorial(10)时间
0.07990392099600285
</code></pre><p>大概4倍的样子, very nice!</p>
<p>第一个例子就到这里了，ctypes打开了Python调用c代码库的大门。 然而很多时候并没有现成的c库给我们调， 那么就需要自己写Python的C Extension了，下一篇我们先研究一下如何裸写一个Python的C extension模块吧.</p>
<p>上面示例的代码已经放到<a href="https://github.com/moonshadow/way-to-python-ninja" target="_blank" rel="external"><strong>github</strong></a>上面了，可以拉下来参照<a href="https://docs.python.org/3.5/library/ctypes.html#module-ctypes" target="_blank" rel="external"><strong>ctypes</strong></a>的文档自己玩玩, 如果你有更好的sample或者建议欢迎一起交流.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写博客的动机&quot;&gt;&lt;a href=&quot;#写博客的动机&quot; class=&quot;headerlink&quot; title=&quot;写博客的动机&quot;&gt;&lt;/a&gt;写博客的动机&lt;/h2&gt;&lt;p&gt;当了这么久的程序员，中间有好几次也想过开个博客写点什么。可是一来觉得自己太菜，再又实在过于怠惰，计划就搁置一旁(买了个域名躺了一年😂)。 然而一直以来看了各路大侠的博客，偷偷学到不少东西, 感觉好像也没那么菜了，也觉着应该把自己的一些想法和见解分享出去，回馈社会, 而不是在自己的脑子里面憋着， 即使被打脸也算是又学到了嘛, 何乐而不为。&lt;/p&gt;
&lt;p&gt;在下一介Python程序员, 而且是&lt;em&gt;真のPython粉&lt;/em&gt;，那就从Python写起吧, 也比较得心应手一点。现今市面上充斥各种Python教程(Python也真是太简单易上手了), 我就不去凑这个热闹也讲些Python基础或者&lt;em&gt;tips&lt;/em&gt;什么的了。将要讲到的内容都是面向至少中级的Python程序员的. 所以读者最好是具备一定的Python水平，如果是刚入门的小朋友, 至少先买两本入门教程撸一遍再来吧，请点击右上角不送。&lt;/p&gt;
&lt;p&gt;暂定的系列有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python C Extension&lt;/li&gt;
&lt;li&gt;Profile&lt;/li&gt;
&lt;li&gt;Debugging&lt;/li&gt;
&lt;li&gt;Python2 or Python3&lt;/li&gt;
&lt;li&gt;Unicode&lt;/li&gt;
&lt;li&gt;AsyncIO&lt;/li&gt;
&lt;li&gt;Modules&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://imiliya.com/categories/Programming/"/>
    
    
      <category term="Python" scheme="http://imiliya.com/tags/Python/"/>
    
      <category term="C" scheme="http://imiliya.com/tags/C/"/>
    
  </entry>
  
</feed>
