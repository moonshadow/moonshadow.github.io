<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wang Haowei - Python Programmer</title>
  <subtitle>Python! Pythoner! Pythonest!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="imiliya.com/"/>
  <updated>2016-08-19T14:51:28.000Z</updated>
  <id>imiliya.com/</id>
  
  <author>
    <name>Moonshadow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>An Introduction to Python C Extension Programming (Part2)</title>
    <link href="imiliya.com/2016/08/19/py-c-ext-part2/"/>
    <id>imiliya.com/2016/08/19/py-c-ext-part2/</id>
    <published>2016-08-18T17:06:53.000Z</published>
    <updated>2016-08-19T14:51:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>TL; DR.</p>
<h2 id="什么是Python-C-Extension？"><a href="#什么是Python-C-Extension？" class="headerlink" title="什么是Python C Extension？"></a>什么是Python C Extension？</h2><p>所谓<a href="https://docs.python.org/3/extending/extending.html" target="_blank" rel="external">Python C Extension</a>， 是指在Cpython平台上面,遵循Python C Extension Interface写出来的c代码模块，经过编译后可以在Python代码中直接import，相当于一个Python Module。 通俗的讲，就是用C语言实现一个library，然后给这个library披一个Python模块的皮，好让Python程序像import其他普通Python模块一样来使用这个C library.</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>我们直接看官方文档的例子来写一个extension 模块吧(偷个懒，这篇文章我就当官方文档的搬运工了)。</p>
<p>创建<code>main.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> spam</div><div class="line"></div><div class="line">status = spam.system(<span class="string">'ls -l'</span>)</div></pre></td></tr></table></figure>
<p>spam是我们将要实现的Extension模块, 使用方式很简单，直接import就行了。</p>
<p>然后我们来实现这个模块。</p>
<a id="more"></a>
<p>创建<code>spam.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> PyObject *SpamError;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> PyObject *<span class="title">spam_system</span><span class="params">(PyObject *self, PyObject *args)</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *command;</div><div class="line">  <span class="keyword">int</span> sts;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">"s"</span>, &amp;command))</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">   sts = system(command);</div><div class="line">   <span class="keyword">if</span> (sts &lt; <span class="number">0</span>) &#123;</div><div class="line">    PyErr_SetString(SpamError, <span class="string">"System command failed"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> PyLong_FromLong(sts);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> PyMethodDef SpamMethods[] = &#123;</div><div class="line">    &#123;<span class="string">"system"</span>, spam_system, METH_VARARGS, <span class="string">"Execute a shell command."</span>&#125;,</div><div class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> PyModuleDef spammodule = &#123;</div><div class="line">    PyModuleDef_HEAD_INIT,</div><div class="line">    <span class="string">"spam"</span>,</div><div class="line">    <span class="string">"spam document"</span>,</div><div class="line">    <span class="number">-1</span>,</div><div class="line">    SpamMethods</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_spam</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    PyObject *m;</div><div class="line"></div><div class="line">    m = PyModule_Create(&amp;spammodule);</div><div class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    SpamError = PyErr_NewException(<span class="string">"spam.error"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Py_INCREF(SpamError);</div><div class="line">    PyModule_AddObject(m, <span class="string">"error"</span>, SpamError);</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>WTF, 都是些什么鬼玩意儿?</p>
<p><code>#include &lt;Python.h&gt;</code> 引入了Python C API的header文件，这样在<code>spam.c</code> 中就可以使用Python.h里面定义的结构， 函数和宏了，<code>Python.h</code>把<code>&lt;stdio.h&gt;, &lt;string.h&gt;, &lt;errno.h&gt;,&lt;stdlib.h&gt;</code>这些标准库的header都已经include了进来。 如果对Python.h里面的东西感兴趣, 在终端跑一下<code>python3-config --cflags</code>, 就能找到文件的位置。</p>
<pre><code>python3-config --cflags
</code></pre><p>在运行结果中找到header的路径(Mac)。</p>
<pre><code>-I/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/include/python3.5m
</code></pre><p>直接cd到<code>/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/include/python3.5m</code>目录就能找到这个header文件, Python源码的其他header文件也都在这里了。</p>
<p><code>static PyObject *SpamError</code>定义了一个SpamError对象, 根据名字可以猜到这将是一个异常类。Python的所有对象对应的都是一个<code>PyObject</code>的结构， 你可以到object.h头文件里面看看PyObject是怎么定义的，不过只能看得一脸懵逼就是了，如果对Python源码好奇，墙裂推荐《Python源码剖析》这本书。 .</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static PyObject *spam_system(PyObject *self, PyObject *<span class="keyword">args</span>) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *command;</div><div class="line">  int <span class="keyword">sts</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!PyArg_ParseTuple(<span class="keyword">args</span>, <span class="string">"s"</span>, &amp;command))</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">   <span class="keyword">sts</span> = system(command);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">sts</span> &lt; 0) &#123;</div><div class="line">    PyErr_SetString(SpamError, <span class="string">"System command failed"</span>);</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> PyLong_FromLong(<span class="keyword">sts</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>spam_system</code>定义了一个静态函数。 <code>self</code>指向的是当前模块，<code>args</code>则是Python调用这个方法时传入的参数.<br><code>PyArg_ParseTuple</code>把<code>args</code>解析成c字符串, 并让command指向这个字符串的地址， 然后调用std的system函数(通过include引入的)。 sts保存了系统调用的返回值，<code>sts &lt; 0</code> 说明调用失败，通过<code>PyErr_SetString</code> 设置异常信息，否则<code>PyLong_FromLong</code>将返回值转换为Python 的int对象.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> PyMethodDef SpamMethods[] = &#123;</div><div class="line">    &#123;<span class="string">"system"</span>, spam_system, METH_VARARGS, <span class="string">"Execute a shell command."</span>&#125;,</div><div class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SpamMethods是模块的成员方法列表，其实就是一个数组, 每个元素都是一个<em>PyMethodDef</em>的结果表示一个模块的一个成员方法. <code>system</code>是最后输出的变量名， spam_system是刚才定义的函数， _METH<em>VARARGS</em>表示Python调用这个函数是传参的方式。 <code>&quot;Execute s shell command&quot;</code> 是函数的注释信息. <code>{NULL, NULL, 0, NULL}</code> 起一个哨兵的作用，这样模块遍历<em>SpamMethods</em>到这里就知道所有成员都已经被定义了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> PyModuleDef spammodule = &#123;</div><div class="line">    PyModuleDef_HEAD_INIT,</div><div class="line">    <span class="string">"spam"</span>,</div><div class="line">    <span class="string">"spam document"</span>,</div><div class="line">    <span class="number">-1</span>,</div><div class="line">    SpamMethods</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义了将要输出的模块对象, 这是一个<code>PyModuleDef</code>结构，spamMethods对应了上面定义的成员数组。 最后我们还需要定义模块的初始化方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_spam</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    PyObject *m;</div><div class="line"></div><div class="line">    m = PyModule_Create(&amp;spammodule);</div><div class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    SpamError = PyErr_NewException(<span class="string">"spam.error"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Py_INCREF(SpamError);</div><div class="line">    PyModule_AddObject(m, <span class="string">"error"</span>, SpamError);</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>import spam</code> 的时候，Python C Extension的模块机制就会执行PyInt_spam函数来创建并初始化模块, 初始化过程中还会创建SpamError类并添加到spam模块的成员变量中, Py_INCREF增加一个SpamError的引用计数(后面会讲到Python 的reference counting).</p>
<p>至此spam模块的实现就算大功告成， 我们需要把他编译成可以直接import的模块. 手动编译设置各种参数比较麻烦，可以利用<code>distutils</code>里面的方法来构建.</p>
<p>创建setup.py</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from distutils.core <span class="keyword">import</span> <span class="built_in">setup</span>, Extension</div><div class="line"></div><div class="line"><span class="built_in">setup</span>(name=<span class="string">'sample'</span>, ext_modules=[</div><div class="line">    Extension(<span class="string">'spam'</span>, [<span class="string">'spam.c'</span>])</div><div class="line">])</div></pre></td></tr></table></figure>
<p>注意Extension的<code>__init__</code>方法第一个参数指定了模块名为spam， 需要和模块初始化PyInit_spam中的spam保持一致， import spam的运行时，会根据这个参数的名字，去调用对应PyInit_name的方法。</p>
<p>运行</p>
<pre><code>python3 setup.py build_ext --inplace
</code></pre><p>会把spam.c编译成对应的dll模块，<code>inplace</code> 选项指定了结果文件的位置是当前目录.</p>
<p>跑一下我们的<code>main.py</code></p>
<pre><code>python3 main.py
</code></pre><p>结果会在终端打印当前目录下的文件。</p>
<p>如果想安装到site-packages下面， 运行<code>python3 setup.py install</code>， 然后就可以在其他项目也能直接import spam模块了。</p>
<p><em>Extension</em> 类的 <em>__init__</em> 方法还接受很多其他的参数: <em>include_dirs</em> 指定包含头文件的路径， <em>define_macros</em> 定义一些宏，<em>library_dirs</em> 指定动态链接的目录, 相当于gcc的 <em>-L</em> 选项，libraries 指定链接的库，相当与gcc的 <em>-l</em> 选项。还有其他一些参数读者请自行参考<a href="https://docs.python.org/3.5/distutils/apiref.html#distutils.core.Extension" target="_blank" rel="external">distutils</a>。</p>
<h2 id="错误和异常-Errors-and-Exception"><a href="#错误和异常-Errors-and-Exception" class="headerlink" title="错误和异常(Errors and Exception)"></a>错误和异常(Errors and Exception)</h2><p>Python解释器有一个不成文的规定， 当函数失败的时候，需要设置一个异常信息，并且返回错误值，异常信息保存在解释器的一个静态全局变量中。如果这个变量的值为NULL，说明没有异常发生。除此之外还有两个全局变量，一个保存了异常信息对应的描述，另一个保存了发生异常时的整个调用堆栈, 它们对应了sys.exc_info()结果的三个元素。</p>
<p>前面用到的PyErr_SetString()方法，第一个参数就是我们定义的异常类对象,第二个参数是关联的异常信息描述。 <em>PyErr_SetString(SpamError, “System command failed”)</em> 设置了全局的异常信息,Python解释器发现这个异常信息的时候，会跳转到异常处理流程(如果想了解Python解释器是怎么运作的, 异常机制又是如何实现的，再次推荐《Python源码剖析》这本书)。</p>
<h2 id="一点题外话——引用计数-Reference-Counts"><a href="#一点题外话——引用计数-Reference-Counts" class="headerlink" title="一点题外话——引用计数(Reference Counts)"></a>一点题外话——引用计数(Reference Counts)</h2><p>C和C++要求程序员负责动态的分配和回收堆上的内存，C语言提供了malloc()和free()函数(C++对应有new和delete操作符)。</p>
<p>每一个malloc()分配的内存资源， 最终都需要通过调用free()来回收, 如果忘记了free， 被分配的内存资源直到进程退出都无法重新利用，这就是所谓的内存泄漏(memory leak)。如果继续使用free()过的内存， 很有可能和以后通过malloc()重新分配的内存资源冲突，会造成同引用没有初始化的指针一样的结果，core dumps, 错误的结果，进程莫名崩溃之类。</p>
<p>常见的内存泄露都是程序忘记调用free造成的，比如错误处理的逻辑中直接return却没有free之前分配的内存，尤其是代码量比较大的时候很容易出现。如果某个有内存泄露的函数被大量的调用，那么每次调用都会造成一定的内存泄漏, 如果只是短暂运行的进程，随着进程结束，这些资源都会被操作系统回收。但是如果是长时间运行的进程（比如一个后台daemon)，没有回收的内存资源会随着程序运行时间的增加而增加，最终把系统资源耗尽，程序崩溃。 所以通过一个好的编码规范避免内存泄露就显得十分重要。</p>
<p>Python大量的使用了malloc和free来管理内存，就必须有一个好的策略来避免上面提到的问题。Python使用的主要方法是 <em>reference counting</em>(引用计数) . 简单地讲， 每一个对象都有一个引用计数器，每当有新的引用，计数器的值+1, 如果引用被删除，计数器的值就-1，当计数器的值减到0，这个对象占用的内存就可以回收了。</p>
<p>引用计数不能解决循环引用的问题，循环引用是指存在互相引用的对象，引用计数永远不可能减到0, 我们来看一个粗暴的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gc</div><div class="line">gc.disable() <span class="comment"># 关闭gc功能</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">  a = [<span class="number">1</span>] * <span class="number">1000000</span></div><div class="line">  b = [<span class="number">1</span>] * <span class="number">1000000</span></div><div class="line">  a.append(b)</div><div class="line">  b.append(a)</div><div class="line">  <span class="keyword">del</span> a</div><div class="line">  <span class="keyword">del</span> b</div></pre></td></tr></table></figure>
<p><strong>友情提示</strong>  千万不要手贱运行上面的代码!! 对于不听劝告的小朋友，如果造成无法挽回的后果本人表示不负任何责任。</p>
<p><code>del a</code>和<code>del b</code>后，我们的程序已经没有对这两个对象的引用了，但是b和a还是互相引用了对象，他们的refcount都是1，那么引用计数机制就永远不会去回收a和b的内存, 每个While循环都会出现一次循环引用，这个程序会迅速蚕食掉你的内存。</p>
<p> Python通过一个叫做<a href="https://en.wikipedia.org/wiki/Cycle_detection" target="_blank" rel="external">cycle detector</a>的技术解决了这个问题，<a href="https://docs.python.org/3/library/gc.html#module-gc" target="_blank" rel="external">gc</a>模块甚至提供了collect方法让程序员自己手动处理循环引用。如果你能保证你的Python代码不会出现循环引用的情况，可以通过<code>--without-cycle-gc</code>这个启动选项关掉自动回收的功能, 不过不建议这么做，Why bothering your self if Python could handle it for you?</p>
<p>也许你可以试试把上面的<code>gc.disable()</code>这一行注释掉再运行这段代码。  Please be very very careful!</p>
<p>Python通过引用计数和垃圾回收，实现了内存的自动管理，把Python程序员从手动内存管理的负担重解脱了出来，下面我们来看看Python的引用计数是具体是怎么玩的。</p>
<h3 id="Reference-Counting-in-Python"><a href="#Reference-Counting-in-Python" class="headerlink" title="Reference Counting in Python"></a>Reference Counting in Python</h3><p>Note:  下面提到<code>ref</code>, <code>reference</code>, <code>引用</code>这三个词没有什么区别。</p>
<p>Python通过两个宏 Py_INCREF(x) and Py_DECREF(x)来操作对象的引用计数。问题是这两个宏都需要在什么时候去调用呢？</p>
<p>Python的API文档中介绍了几个术语。</p>
<ul>
<li><p><strong>own</strong>: 一个对象有很多个reference，每个reference对应会有一个owner， 一个对象的引用计数就是owner的个数. owner可以通过传递， 保存，或者直接Py_DECREF()来放弃对这个对象的reference。</p>
</li>
<li><p><strong>borrow</strong>:  并不own一个reference，不会增加对象的引用计数，因此也不需要调用Py_DECREF, 如果对一个borrow的reference调用了Py_INCREF， 就把他变成了一个owner。</p>
</li>
</ul>
<p>当一个对象的引用作为参数传入函数或者作为函数的返回结果时， 根据函数的接口定义，我们可以知道对应ownership有没有被转移。</p>
<p>大多数返回一个引用的函数会把ownership交给调用者， 一般的如果函数创建了新的对象并返回对这个对象的引用，比如PyLong_FromLong(), Py_BuildValue, 那么这个引用的ownership转给了调用者。例外的是 PyTuple_GetItem(), PyList_GetItem(), PyDict_GetItem(), and PyDict_GetItemString()这些函数，只是返回一个borrowed引用。</p>
<p>当对象引用作为参数传入函数的时候，一般情况下函数都是borrow了这个reference，并不增加引用计数，如果函数需要增加引用计数，需要显示调用Py_INCREF。 不过也有例外， PyTuple_SetItem() and PyList_SetItem()这两个函数就接管了引用成为owner。</p>
<p>是不是感觉很抽象(反正我刚开始的时候就是一脸懵逼), 为什么一会儿要borrow一会儿要own的…下面举几个例子来分析一下你应该就能稍微明白一点了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PyList_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    PyList_SetItem(<span class="built_in">list</span>, <span class="number">1</span>, PyLong_FromLong(<span class="number">0L</span>));</div><div class="line">    PyObject_Print(item, <span class="built_in">stdout</span>, <span class="number">0</span>); <span class="comment">/* BUG! */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PyList_GetItem返回了list第一个元素的引用，根据<a href="https://docs.python.org/3.5/c-api/list.html#c.PyList_GetItem" target="_blank" rel="external">PyList_GetItem</a>的文档我们知道这个函数返回的是一个borrowed引用, 也就是说不会增加list[0]这个元素的引用计数（我们假设现在list[0],list[1]的refcount都是1), 接下来我们设置list[1]元素的值为0(新创建的int对象)，而原先的list[1]引用的对象的refcount就会减1变成0，这个时候 原先list[1]对象的<a href="https://docs.python.org/3/reference/datamodel.html#object.__del__" target="_blank" rel="external"><code>__del__</code></a>就会被调用，而<code>__del__</code>方法可以直接访问list[0]的元素，如果在里面调用del list[0], list[0]元素的引用计数也减为0了，PyObject_Print函数就会访问到一个已经被回收的内存地址, 下面是模拟这个场景的python代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">list0 = object()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">del</span> list0</div><div class="line"></div><div class="line">list1 = Obj()</div><div class="line">l = [list0, list1]</div></pre></td></tr></table></figure></p>
<p>所以如果是borrow一个引用的话，必须保证在使用这个引用的过程中这个引用对象的refcount不会减为0, 修改前面的C代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">no_bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PyList_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    Py_INCREF(item);</div><div class="line">    PyList_SetItem(<span class="built_in">list</span>, <span class="number">1</span>, PyLong_FromLong(<span class="number">0L</span>));</div><div class="line">    PyObject_Print(item, <span class="built_in">stdout</span>, <span class="number">0</span>);</div><div class="line">    Py_DECREF(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在PyList_SetItem之前增加item对象引用计数，保证了PyObject_Print访问到的item的有效性。</p>
<p>或者使用<a href="https://docs.python.org/3.5/c-api/sequence.html#c.PySequence_GetItem" target="_blank" rel="external">PySequence_GetItem</a>方法，查看文档我们发现这个函数返回的是一个owner reference，增加了一个对对应元素对象的引用计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">no_bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PySequence_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line">    PyList_SetItem(<span class="built_in">list</span>, <span class="number">1</span>, PyLong_FromLong(<span class="number">0L</span>));</div><div class="line">    PyObject_Print(item, <span class="built_in">stdout</span>, <span class="number">0</span>);</div><div class="line">    Py_DECREF(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要用完之后调用Py_DECREF来去掉刚才增加的引用计数, 但是值得注意的是PySequence_GetItem既然返回的是一个owner, 那么用这个它的目的就是要长时间占用的，而不是像上面这样只是print一下, 这个地方用PySequence_GetItem其实已经失去本意了, 用PyList_GetItem暂时borrow一下是更加正确的选择。</p>
<p>所以你发现borrow和own的区别了么? borrow过来reference的不会占用一个计数，在使用borrow的引用过程中必须要自己保证引用有效，如果可以保证中间没有操作可能减少这个引用计数的话，我们甚至省去了INC和DEC引用的烦恼，所谓borrow就是我借过来用一下，等下肯定会还你的。这个比喻其实有一点不恰当的地方，因为borrow的reference其实也被借出方占着的，比如上面的list也还是可以访问item对象，借的过程中借用方甚至还要担心被借走的东西被已经被处理掉的可能（PyList_SetItem）， 这其实就不叫借了吧，还不如说是暂时share给你一会儿，虽然你也能用，但是别人问起来你得说这个东西你并没有所有权, 而且share给你的人心情不好把东西给卖了你就用不了了，这个时候Py_INCREF就好像在说你先别卖啊，我还没用完呢，Py_DECREF则是说我现在已经不用了，你爱怎么玩怎么玩。own就不一样了，如果我们两个都own了一个东西，那么光你说卖还不成，你只能说自己不要了（像del list0)那样，但是我还占着一份呢，Py_DECREF则是说现在我也不想要了——喂，那个捡垃圾的(item的 <code>__del__</code> 方法)，你来拿走吧。 不知道这样表述清不清楚。</p>
<p>对于上面的例子，Python的GIL保证了这个函数调用过程不会被其他线程打断,因此我们不必担心被borrow的引用item在另一个线程被回收了（比如在另一个thread调用了PyList_SetItem，里面又做了减少item引用计数的事情（论GIL的重要性). 但是python提供了Py_BEGIN_ALLOW_THREADS这个宏来暂时解除全局锁，看看下面的这个代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bug</span><span class="params">(PyObject *<span class="built_in">list</span>)</span></div><div class="line">&#123;</div><div class="line">    PyObject *item = PyList_GetItem(<span class="built_in">list</span>, <span class="number">0</span>);</div><div class="line">    Py_BEGIN_ALLOW_THREADS</div><div class="line">    ...some blocking I/O call...</div><div class="line">    <span class="function">Py_END_ALLOW_THREADS</span></div><div class="line">    <span class="title">PyObject_Print</span><span class="params">(item, <span class="built_in">stdout</span>, <span class="number">0</span>)</span>; <span class="comment">/* BUG! */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Py_BEGIN_ALLOW_THREADS和Py_END_ALLOW_THREADS之间，GIL被释放了，于是item就有可能在另一个线程被回收掉，后面在执行 PyObject_Print就可能产生意想不到的bug!</p>
<p>讲了这么多引用计数的东西好像已经偏题了, 看得出来在C Extension里面对引用计数的处理也是一件比较tricky的事情。如果你对这块很感兴趣，直接阅读<a href="https://docs.python.org/3/extending/extending.html" target="_blank" rel="external">官方文档</a>是一个不错的选择, 这篇文章<a href="http://edcjones.tripod.com/refcount.html" target="_blank" rel="external">http://edcjones.tripod.com/refcount.html</a>则做了一定的解释和补充。 please keep reading patiently!</p>
<p>如果你对 <em>borrow</em>，<em>own</em> 这一块很感兴趣 ,隔壁有一门叫做<a href="https://doc.rust-lang.org" target="_blank" rel="external">Rust</a>的语言值得尝试, 可以看看它的 <em>ownership system</em> 是怎么玩的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的讲, 实现一个C Extension模块要做好三件事情</p>
<ol>
<li>满足C Extension接口的规范</li>
<li>处理好数据在Python和C之间的转化</li>
<li>用C语言实现具体的功能（或者调用已有的库)</li>
</ol>
<p>再回顾一下我们的spam.c文件，所有变量的定义都是static的，表示这些变量的作用域仅限于<code>spam.c</code>，起到了限制作用域的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SpamError = PyErr_NewException(<span class="string">"spam.error"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">Py_INCREF(SpamError);</div><div class="line">PyModule_AddObject(m, <span class="string">"error"</span>, SpamError);</div></pre></td></tr></table></figure>
<p>因为<a href="https://docs.python.org/3.5/c-api/module.html#c.PyModule_AddObject" target="_blank" rel="external">PyModule_AddObject</a>不会增加SpamError的引用计数,官方的话叫steal the reference, 如果我们不手动INC一下，那么以后删除了m.error这个属性的话，SpamError的计数就变0，对应的内存被回收，如果后面又抛出了这个异常救护出现意想不到的错误。</p>
<p>PyArg_ParseTuple的format参数格式请参考<a href="https://docs.python.org/3/c-api/arg.html" target="_blank" rel="external">PyArg_ParseTuple</a>, 与之对应的还有<code>Py_BuildValue</code> 函数， 用来构造Python对象.</p>
<p><a href="https://github.com/moonshadow/way-to-python-ninja/tree/master/python-c-ext/impl-python-c-ext" target="_blank" rel="external">相关代码</a></p>
<p>Anyway, 手动实现一个Python C Extension始终是一件很麻烦的事(还要了解Python的引用计数是怎么玩的)。如果只是简单系统调用，用<code>ctypes</code>就能直接搞定， 那专心写好C代码，然后直接让Python像用普通模块一样把它用起来岂不是更加方便？ 下一篇我们就来看看一个叫做CFFI的第三方库又是怎么实现在Python中调用C语言库的吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TL; DR.&lt;/p&gt;
&lt;h2 id=&quot;什么是Python-C-Extension？&quot;&gt;&lt;a href=&quot;#什么是Python-C-Extension？&quot; class=&quot;headerlink&quot; title=&quot;什么是Python C Extension？&quot;&gt;&lt;/a&gt;什么是Python C Extension？&lt;/h2&gt;&lt;p&gt;所谓&lt;a href=&quot;https://docs.python.org/3/extending/extending.html&quot;&gt;Python C Extension&lt;/a&gt;， 是指在Cpython平台上面,遵循Python C Extension Interface写出来的c代码模块，经过编译后可以在Python代码中直接import，相当于一个Python Module。 通俗的讲，就是用C语言实现一个library，然后给这个library披一个Python模块的皮，好让Python程序像import其他普通Python模块一样来使用这个C library.&lt;/p&gt;
&lt;h2 id=&quot;简单实现&quot;&gt;&lt;a href=&quot;#简单实现&quot; class=&quot;headerlink&quot; title=&quot;简单实现&quot;&gt;&lt;/a&gt;简单实现&lt;/h2&gt;&lt;p&gt;我们直接看官方文档的例子来写一个extension 模块吧(偷个懒，这篇文章我就当官方文档的搬运工了)。&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;main.py&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; spam&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;status = spam.system(&lt;span class=&quot;string&quot;&gt;&#39;ls -l&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;spam是我们将要实现的Extension模块, 使用方式很简单，直接import就行了。&lt;/p&gt;
&lt;p&gt;然后我们来实现这个模块。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="imiliya.com/categories/Programming/"/>
    
    
      <category term="Python" scheme="imiliya.com/tags/Python/"/>
    
      <category term="C" scheme="imiliya.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>An Introduction to Python C Extension Programming (Part1)</title>
    <link href="imiliya.com/2016/08/16/py-ext/"/>
    <id>imiliya.com/2016/08/16/py-ext/</id>
    <published>2016-08-16T00:45:36.000Z</published>
    <updated>2016-08-18T18:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写博客的动机"><a href="#写博客的动机" class="headerlink" title="写博客的动机"></a>写博客的动机</h2><p>当了这么久的程序员，中间有好几次也想过开个博客写点什么。可是一来觉得自己太菜，再又实在过于怠惰，计划就搁置一旁(买了个域名躺了一年😂)。 然而一直以来看了各路大侠的博客，偷偷学到不少东西, 感觉好像也没那么菜了，也觉着应该把自己的一些想法和见解分享出去，回馈社会, 而不是在自己的脑子里面憋着， 即使被打脸也算是又学到了嘛, 何乐而不为。</p>
<p>在下一介Python程序员, 而且是<em>真のPython粉</em>，那就从Python写起吧, 也比较得心应手一点。现今市面上充斥各种Python教程(Python也真是太简单易上手了), 我就不去凑这个热闹也讲些Python基础或者<em>tips</em>什么的了。将要讲到的内容都是面向至少中级的Python程序员的. 所以读者最好是具备一定的Python水平，如果是刚入门的小朋友, 至少先买两本入门教程撸一遍再来吧，请点击右上角不送。</p>
<p>暂定的系列有</p>
<ol>
<li>Python C Extension</li>
<li>Profile</li>
<li>Debugging</li>
<li>Python2 or Python3</li>
<li>Unicode</li>
<li>AsyncIO</li>
<li>Modules</li>
<li>Logging</li>
</ol>
<a id="more"></a>
<h2 id="First-of-first-Python-C-Extension"><a href="#First-of-first-Python-C-Extension" class="headerlink" title="First of first (Python C Extension)"></a>First of first (Python C Extension)</h2><p>不知道大家觉得Python最神秘的地方在哪里。反正在我的经验看来，最搞不清扯不明的地方就是所谓的Python C Extension Module了。ctypes， cffi， swig， cython, numba这些名词，听上去就觉得好可怕, 想搜个像样子的介绍文章出来都难, 直接看官方文档吧有感觉有点overwhelming. 所以我希望通过C Extension这个系列的文章，把这些玩意儿一个一个都探索一下。 本人C语言水平有限，如果有胡说八道的地方， 欢迎指正，大家一起学习进步😀。 以后所有文章只针对Python3，关于<em>Python2 or Python3</em>, 以后也会找机会讨论一下, 如果有必要联系Python2的相关知识我会专门指出, 文中所有涉及到编译c代码的地方都假设读者使用的是类unix的操作系统(原因是我对windows的生态系统实在一无所知)。</p>
<h2 id="why-C"><a href="#why-C" class="headerlink" title="why C?"></a>why C?</h2><p>好吧，我们用Python是因为它很高的抽象层次，可以帮助我们迅速的构建应用，不论是写一个简单的任务脚本还是搭一个小型网站，Python都是上佳选择。然而世上没有免费午餐，开发效率的代价是牺牲了软件性能，不过一般情况下这都不是事，比如Python构建的web app性能瓶颈大多都在IO，这是没法在代码层面优化的, 可以通过改变IO模型或者扩容服务器来解决。而且一般的Python程序员习惯了Python的简介优雅，可能对性能什么的没什么概念。不过夜路走多了总会撞鬼，平常没有意识，真正性能出现问题需要优化的时候只能是一脸懵逼。如果能够具备一定的性能意识，在需要的时候知道有哪些办法可以选择和尝试，那么至少是走在了正确的道路上。性能Profile也是一个大的话题，以后再展开。</p>
<p>学习C Extension Programming也能加深对Python语言本身的理解， 对于写出更高质量的Python代码也是很有帮助的。 所以废话不多说，进入第一个话题，如何在Python代码里面调用C函数.</p>
<h2 id="How-to-call-C-function-in-Python-code"><a href="#How-to-call-C-function-in-Python-code" class="headerlink" title="How to call C function in Python code?"></a>How to call C function in Python code?</h2><p>python标准库提供了<a href="https://docs.python.org/3.5/library/ctypes.html#module-ctypes" target="_blank" rel="external"><strong>ctypes</strong></a>模块, 可以帮助我们把DLL或者shared libraries(共享库)中的函数封装成可以直接调用的Python函数。如果发现需要的某个工具已经有C语言的library, 我们就不需要重新用Python实现相同功能的模块， 既保证了效率还能省去性能的烦恼。下面是一个简单的例子:</p>
<p>首先我们创建一个C文件<code>utils.c</code>, 定义factorial和swap两个函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> factorial(x<span class="number">-1</span>) * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> temp = *a;</div><div class="line">  *a = *b;</div><div class="line">  *b = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后编译成目标文件<code>utils.o</code>(我用的是Mac下面的LLVM编译器）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c -Wall -Werror utils.c</div></pre></td></tr></table></figure>
<p>再把刚生成的目标文件转化成动态链接库.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libutils</span><span class="selector-class">.so</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></div></pre></td></tr></table></figure>
<p>我们需要做的就是在<em>Python</em>代码中调用刚才在<code>utils.c</code>中定义的两个函数. 下面示例如何用<em>ctypes</em>来操作，创建文件<code>main.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ctypes</div><div class="line"></div><div class="line"></div><div class="line">utils = ctypes.cdll.LoadLibrary(<span class="string">'./libutils.so'</span>)</div><div class="line"></div><div class="line">factorial = utils.factorial</div><div class="line">factorial.argtypes = (ctypes.c_int,)</div><div class="line">factorial.restype = ctypes.c_int</div><div class="line"></div><div class="line">_swap  = utils.swap</div><div class="line">_swap.argtypes = (ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(x, y)</span>:</span></div><div class="line">    a = ctypes.c_int(x)</div><div class="line">    b = ctypes.c_int(y)</div><div class="line">    _swap(a, b)</div><div class="line">    <span class="keyword">return</span> a.value, b.value</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    print(<span class="string">'factorial of 4 is %s !'</span> % factorial(<span class="number">4</span>))</div><div class="line">    print(<span class="string">'factorial of 5 is %s !'</span> % factorial(<span class="number">5</span>))</div><div class="line"></div><div class="line">    x, y = <span class="number">10</span>, <span class="number">20</span></div><div class="line">    print(<span class="string">'x is %s and y is %s'</span> % (x, y))</div><div class="line">    x, y = swap(x, y)</div><div class="line">    print(<span class="string">'after swap'</span>)</div><div class="line">    print(<span class="string">'x is %s and y is %s'</span> % (x, y))</div></pre></td></tr></table></figure>
<p><code>utils = ctypes.cdll.LoadLibrary(&#39;./libutils.so&#39;)</code> 载入了已经编译好的<code>libutils.so</code>, factorial和swap两个函数变成了模块的locals.（如果不是自己编译的模块而是想用系统的C语言共享库，参考<code>cypes.utils</code>的<code>find_library</code>方法，路径通常都是<code>/usr/lib</code> 和 <code>/usr/local/lib</code>， linux操作系统默认都是<em>libxxx.so</em>的格式， 而os x则是<em>libxxx.dylib</em>)</p>
<p>对于<code>factorial</code>函数，只需要把python的int对象转换成对应的ctype类型再传入factorial函数， 同时需要定义返回的结果类型，把factorial函数返回的int转换成Python的int对象</p>
<p><code>swap</code>函数稍微麻烦一点，因为Python不能直接访问指针，所以需要把已有的c函数稍微做个封装， 不过思路一样就是了.</p>
<p>最后验证一下结果。<br>运行</p>
<pre><code>python3 main.py
</code></pre><p>终端输出</p>
<pre><code>factorial of 4 is 24 !
factorial of 5 is 120 !
x is 10 and y is 20
after swap
x is 20 and y is 10
</code></pre><p>Perfect! 简单的几个步骤，我们就实现了在Python中调用c函数.</p>
<p>顺便我们对比一下C语言实现的factorial和Python版本的性能,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ctypes</div><div class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</div><div class="line"></div><div class="line"></div><div class="line">utils = ctypes.cdll.LoadLibrary(<span class="string">'./libutils.so'</span>)</div><div class="line"></div><div class="line">factorial = utils.factorial</div><div class="line">factorial.argtypes = (ctypes.c_int,)</div><div class="line">factorial.restype = ctypes.c_int</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">py_factorial</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">assert</span> isinstance(n, int)</div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> py_factorial(n<span class="number">-1</span>) * n</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    number = <span class="number">100000</span></div><div class="line">    print(<span class="string">'Python 版本100000次的factorial(10)时间'</span>)</div><div class="line">    print(timeit(<span class="string">'py_factorial(10)'</span>, number=number, globals=globals()))</div><div class="line">    print(<span class="string">'C 版本100000次的factorial(10)时间'</span>)</div><div class="line">    print(timeit(<span class="string">'factorial(10)'</span>, number=number, globals=globals()))</div></pre></td></tr></table></figure>
<p>保存到<code>benchmark.py</code></p>
<p>在我的机器上运行的结果是</p>
<pre><code>Python 版本100000次的factorial(10)时间
0.3275668309943285
C 版本100000次的factorial(10)时间
0.07990392099600285
</code></pre><p>大概4倍的样子, very nice!</p>
<p>第一个例子就到这里了，ctypes打开了Python调用c代码库的大门。 然而很多时候并没有现成的c库给我们调， 那么就需要自己写Python的C Extension了，下一篇我们先研究一下如何裸写一个Python的C extension模块吧.</p>
<p>上面示例的代码已经放到<a href="https://github.com/moonshadow/way-to-python-ninja" target="_blank" rel="external"><strong>github</strong></a>上面了，可以拉下来参照<a href="https://docs.python.org/3.5/library/ctypes.html#module-ctypes" target="_blank" rel="external"><strong>ctypes</strong></a>的文档自己玩玩, 如果你有更好的sample或者建议欢迎一起交流.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写博客的动机&quot;&gt;&lt;a href=&quot;#写博客的动机&quot; class=&quot;headerlink&quot; title=&quot;写博客的动机&quot;&gt;&lt;/a&gt;写博客的动机&lt;/h2&gt;&lt;p&gt;当了这么久的程序员，中间有好几次也想过开个博客写点什么。可是一来觉得自己太菜，再又实在过于怠惰，计划就搁置一旁(买了个域名躺了一年😂)。 然而一直以来看了各路大侠的博客，偷偷学到不少东西, 感觉好像也没那么菜了，也觉着应该把自己的一些想法和见解分享出去，回馈社会, 而不是在自己的脑子里面憋着， 即使被打脸也算是又学到了嘛, 何乐而不为。&lt;/p&gt;
&lt;p&gt;在下一介Python程序员, 而且是&lt;em&gt;真のPython粉&lt;/em&gt;，那就从Python写起吧, 也比较得心应手一点。现今市面上充斥各种Python教程(Python也真是太简单易上手了), 我就不去凑这个热闹也讲些Python基础或者&lt;em&gt;tips&lt;/em&gt;什么的了。将要讲到的内容都是面向至少中级的Python程序员的. 所以读者最好是具备一定的Python水平，如果是刚入门的小朋友, 至少先买两本入门教程撸一遍再来吧，请点击右上角不送。&lt;/p&gt;
&lt;p&gt;暂定的系列有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python C Extension&lt;/li&gt;
&lt;li&gt;Profile&lt;/li&gt;
&lt;li&gt;Debugging&lt;/li&gt;
&lt;li&gt;Python2 or Python3&lt;/li&gt;
&lt;li&gt;Unicode&lt;/li&gt;
&lt;li&gt;AsyncIO&lt;/li&gt;
&lt;li&gt;Modules&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Programming" scheme="imiliya.com/categories/Programming/"/>
    
    
      <category term="Python" scheme="imiliya.com/tags/Python/"/>
    
      <category term="C" scheme="imiliya.com/tags/C/"/>
    
  </entry>
  
</feed>
